<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Advanced usage of EpicServer including custom configuration, multiple database connections, authentication hooks, custom middleware, SPA support, and test coverage.">
    <meta name="keywords" content="Go, Golang, Web Server, Advanced, EpicServer, Custom Configuration, Database, Authentication, Middleware, SPA, Testing">
    <meta name="author" content="tomskip123">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Advanced Usage - EpicServer Documentation">
    <meta property="og:description" content="Advanced usage of EpicServer including custom configuration, multiple database connections, authentication hooks, custom middleware, SPA support, and test coverage.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tomskip123.github.io/EpicServer/advanced-usage.html">
    <title>Advanced Usage - EpicServer Documentation</title>
    <link rel="stylesheet" href="styles.css">
    <script src="script.js"></script>
    <link rel="canonical" href="https://tomskip123.github.io/EpicServer/advanced-usage.html">
    <!-- Add highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/yaml.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        });
    </script>
</head>
<body>
    <header>
        <nav class="nav" aria-label="Main Navigation">
            <a href="index.html">Home</a>
            <a href="getting-started.html">Getting Started</a>
            <a href="core-features.html">Core Features</a>
            <a href="advanced-usage.html">Advanced Usage</a>
            <a href="security.html">Security</a>
            <a href="package-reference.html">Package Reference</a>
            <a href="changelog.html">Changelog</a>
        </nav>
    </header>

    <main class="container">
        <article>
            <header>
                <h1>Advanced Usage</h1>
            </header>
            
            <div class="toc">
                <h3>On This Page</h3>
                <ul>
                    <li><a href="#custom-configuration">Custom Configuration</a></li>
                    <li><a href="#multiple-database-connections">Multiple Database Connections</a></li>
                    <li><a href="#authentication-hooks">Authentication Hooks</a></li>
                    <li><a href="#custom-middleware">Custom Middleware</a></li>
                    <li><a href="#spa-support">SPA Support</a></li>
                    <li><a href="#test-coverage">Test Coverage</a></li>
                </ul>
            </div>

            <section>
                <h2 id="custom-configuration">Custom Configuration</h2>
                <p>EpicServer allows you to add your own configuration values to customize server behavior.</p>

                <div class="code-container">
                    <div class="code-header">Custom Configuration Example</div>
                    <pre><code class="language-go">type MyCustomConfig struct {
    APIKey      string
    MaxRequests int
    Features    []string
}

customConfig := MyCustomConfig{
    APIKey:      "my-api-key",
    MaxRequests: 1000,
    Features:    []string{"feature1", "feature2"},
}

server := EpicServer.NewServer([]EpicServer.Option{
    EpicServer.SetCustomConfig(customConfig),
})

// Access custom config in handlers
func MyHandler(c *gin.Context, s *EpicServer.Server) {
    config := EpicServer.GetCustomConfig(s).(MyCustomConfig)
    apiKey := config.APIKey
    // Use configuration...
}</code></pre>
                </div>

                <h3>Replacing Default Middleware</h3>
                <p>If you need to replace or customize default middleware (such as compression), you can create a custom server initialization that skips the default middleware:</p>

                <div class="code-container">
                    <div class="code-header">Custom Middleware Initialization</div>
                    <pre><code class="language-go">// Create a server without default middleware
server := &EpicServer.Server{
    Config: EpicServer.defaultConfig(),
    Engine: gin.New(), // Use gin.New() instead of gin.Default() to avoid default middleware
}

// Initialize the logger
server.Logger = EpicServer.defaultLogger(os.Stdout)

// Setup default hooks
server.Hooks = EpicServer.defaultHooks(server)

// Add only the middleware you want
server.Engine.Use(EpicServer.LoggerMiddleware(server.Logger))
server.Engine.Use(EpicServer.RequestTimingMiddleware(server.Logger))
server.Engine.Use(MyCustomCompressMiddleware()) // Your custom compression middleware
server.Engine.Use(EpicServer.RemoveWWWMiddleware())</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">Custom Middleware Initialization</div>
                    <pre><code class="language-go">// Create a wrapper function that initializes a server without 
// default middleware or with custom middleware
func NewCustomServer(options []EpicServer.Option) *EpicServer.Server {
    // Create a new server with options but don't use directly
    baseServer := EpicServer.NewServer(options)
    
    if baseServer.HasErrors() {
        return baseServer // Return with errors
    }
    
    // Create a new clean engine
    baseServer.Engine = gin.New() // Replace the engine
    
    // Add only the middleware you want
    baseServer.Engine.Use(EpicServer.LoggerMiddleware(baseServer.Logger))
    baseServer.Engine.Use(EpicServer.RequestTimingMiddleware(baseServer.Logger))
    baseServer.Engine.Use(MyCustomCompressMiddleware()) // Your custom compression
    baseServer.Engine.Use(EpicServer.RemoveWWWMiddleware())
    
    return baseServer
}

// Usage
server := NewCustomServer([]EpicServer.Option{
    EpicServer.SetSecretKey([]byte("your-secret-key")),
    EpicServer.SetPort(8080),
})</code></pre>
                </div>

                <h3>Specifying Your Own Default Layers</h3>
                <p>If you want to completely customize the default layers while still using the standard server initialization flow, you can create a wrapper function around <code>NewServer</code>:</p>

                <div class="code-container">
                    <div class="code-header">Custom Default Layers</div>
                    <pre><code class="language-go">// Create a function that initializes a server with your custom default layers
func NewCustomServer(options []EpicServer.Option) *EpicServer.Server {
    // Initialize the server with default configuration
    config := EpicServer.defaultConfig()

    // Apply options to modify the configuration
    for _, opt := range options {
        opt(config)
    }

    // Validate configuration
    if err := config.Validate(); err != nil {
        s := &EpicServer.Server{
            Config: config,
            errors: []error{err},
        }
        return s
    }

    // Initialize Gin engine
    engine := gin.New()

    s := &EpicServer.Server{
        Config:      config,
        Engine:      engine,
        PublicPaths: make(map[string]bool),
        AuthConfigs: make(map[string]*EpicServer.Auth),
        Db:          make(map[string]interface{}),
        Cache:       make(map[string]interface{}),
        errors:      make([]error, 0),
    }

    // Initialize the logger
    s.Logger = EpicServer.defaultLogger(os.Stdout)

    // Setup default hooks
    s.Hooks = EpicServer.defaultHooks(s)

    // Setup YOUR custom default layers
    myDefaultLayers := []EpicServer.AppLayer{
        EpicServer.WithLoggerMiddleware(), // Usually keep this first
        EpicServer.WithHealthCheck("/custom-health"), // Customize health check path
        // Skip compression if you don't want it
        // EpicServer.WithCompression(),
        // Add your own custom middleware
        MyCustomMiddleware(),
        // Keep other default middleware you want
        EpicServer.WithRemoveWWW(),
        EpicServer.WithEnvironment(config.Server.Environment),
    }

    // Apply your custom default layers
    for _, layer := range myDefaultLayers {
        layer(s)
    }

    return s
}</code></pre>
                </div>
            </section>

            <section>
                <h2 id="multiple-database-connections">Multiple Database Connections</h2>
                <p>You can configure multiple database connections with different connection names:</p>

                <div class="code-container">
                    <div class="code-header">Multiple Database Connections</div>
                    <pre><code class="language-go">server := EpicServer.NewServer([]EpicServer.Option{
    EpicServer.SetSecretKey([]byte("your-secret-key")),
})

server.UpdateAppLayer([]EpicServer.AppLayer{
    // Configure multiple databases
    EpicServerDb.WithMongo(&EpicServerDb.MongoConfig{
        ConnectionName: "users",
        URI:           "mongodb://localhost:27017",
        DatabaseName:  "users",
    }),
    EpicServerDb.WithPostgres(EpicServerDb.PostgresConfig{
        ConnectionName: "products",
        Host:          "localhost",
        Database:      "products",
        // ...other config
    }),
    EpicServerDb.WithMySQL(EpicServerDb.MySQLConfig{
        ConnectionName: "orders",
        Host:          "localhost",
        Database:      "orders",
        // ...other config
    }),
})</code></pre>
                </div>

                <p>You can then access these connections in your handlers using their connection names:</p>

                <div class="code-container">
                    <div class="code-header">Accessing Multiple Databases</div>
                    <pre><code class="language-go">func MyHandler(c *gin.Context, s *EpicServer.Server) {
    // Access MongoDB for users
    usersClient := EpicServerDb.GetMongoClient(s, "users")
    usersCollection := usersClient.Database("users").Collection("profiles")
    
    // Access PostgreSQL for products
    productsDB := EpicServerDb.GetPostgresDB(s, "products")
    var products []Product
    productsDB.Find(&products)
    
    // Access MySQL for orders
    ordersDB := EpicServerDb.GetMySQLDB(s, "orders")
    var orders []Order
    ordersDB.Raw("SELECT * FROM orders WHERE status = ?", "pending").Scan(&orders)
}</code></pre>
                </div>
            </section>

            <section>
                <h2 id="authentication-hooks">Authentication Hooks</h2>
                <p>Implement custom authentication logic with authentication hooks:</p>

                <div class="code-container">
                    <div class="code-header">Custom Authentication Hooks</div>
                    <pre><code class="language-go">type MyAuthHooks struct {
    db *Database
}

func (h *MyAuthHooks) OnUserCreate(user EpicServer.Claims) (string, error) {
    // Create user in database
    return userID, nil
}

func (h *MyAuthHooks) GetUserOrCreate(user EpicServer.Claims) (*EpicServer.CookieContents, error) {
    // Get or create user and return session data
    return &EpicServer.CookieContents{
        UserId:     user.UserID,
        Email:      user.Email,
        SessionId:  generateSessionID(),
        IsLoggedIn: true,
        ExpiresOn:  time.Now().Add(time.Hour * 24),
    }, nil
}

// Add auth hooks to server
server.UpdateAppLayer([]EpicServer.AppLayer{
    EpicServer.WithAuthHooks(&MyAuthHooks{db: db}),
})</code></pre>
                </div>
            </section>

            <section>
                <h2 id="custom-middleware">Custom Middleware</h2>
                <p>Create your own middleware to extend server functionality:</p>

                <div class="code-container">
                    <div class="code-header">Custom Middleware</div>
                    <pre><code class="language-go">func MyCustomMiddleware() AppLayer {
    return func(s *EpicServer.Server) {
        s.Engine.Use(func(c *gin.Context) {
            // Pre-processing
            c.Set("custom_key", "custom_value")
            
            c.Next()
            
            // Post-processing
            status := c.Writer.Status()
            if status >= 500 {
                s.Logger.Error("Server error occurred", EpicServer.F("status", status))
            }
        })
    }
}

// Usage
server := EpicServer.NewServer([]EpicServer.Option{
    EpicServer.SetSecretKey([]byte("your-secret-key")),
})

server.UpdateAppLayer([]EpicServer.AppLayer{
    MyCustomMiddleware(),
})</code></pre>
                </div>

                <h3>Middleware Order</h3>
                <p>Middleware is executed in the order it's added. Be aware that some middleware is already included by default.</p>

                <div class="code-container">
                    <div class="code-header">Middleware Order</div>
                    <pre><code class="language-go">// Default middleware is applied first in this order:
// 1. WithLoggerMiddleware()
// 2. WithHealthCheck("/health")
// 3. WithCompression()
// 4. WithRemoveWWW()
// 5. WithEnvironment(config.Server.Environment)

// Then your custom middleware is applied:
server := EpicServer.NewServer([]EpicServer.Option{
    EpicServer.SetSecretKey([]byte("your-secret-key")),
})

server.UpdateAppLayer([]EpicServer.AppLayer{
    // DO NOT add middleware that's already included by default
    // EpicServer.WithCompression(),    // WRONG: Already included by default
    
    // DO add custom middleware you need
    EpicServer.WithCors(origins),    // This will be 6th in execution order
    MyCustomMiddleware(),            // This will be 7th in execution order
})</code></pre>
                </div>
            </section>

            <section>
                <h2 id="spa-support">SPA Support</h2>
                <p>Configure the server to handle Single Page Application (SPA) routing:</p>

                <div class="code-container">
                    <div class="code-header">SPA Support</div>
                    <pre><code class="language-go">//go:embed dist/*
var spaFiles embed.FS

func main() {
    server := EpicServer.NewServer([]EpicServer.Option{
        EpicServer.SetSecretKey([]byte("your-secret-key")),
    })
    
    server.UpdateAppLayer([]EpicServer.AppLayer{
        // Configure SPA handling
        EpicServer.WithSPACatchAll(
            &spaFiles,              // Embedded filesystem
            "dist",                 // Static files directory
            "dist/index.html",      // SPA entry point
        ),
    })
    
    server.Start()
}</code></pre>
                </div>

                <p>This configuration ensures that all routes not explicitly handled by your API will be directed to your SPA's index.html file, allowing client-side routing to work correctly.</p>
            </section>

            <section>
                <h2 id="test-coverage">Test Coverage</h2>
                <p>EpicServer maintains high test coverage standards to ensure reliability and stability.</p>

                <h3>Running Test Coverage Analysis</h3>
                <p>To run tests and generate a coverage report:</p>

                <div class="code-container">
                    <div class="code-header">Test Coverage Commands</div>
                    <pre><code class="language-bash"># Run the test coverage script
./test-coverage.sh

# Run with options to exclude test helpers (default behavior)
./test-coverage.sh

# Run without failing on coverage threshold
./test-coverage.sh --no-fail

# Run including test helpers in coverage calculation
./test-coverage.sh --include-test-helpers

# Combine options
./test-coverage.sh --no-fail --include-test-helpers</code></pre>
                </div>

                <p>The coverage report will be generated in the <code>coverage</code> directory. The HTML report provides detailed information about which code paths are covered by tests and which need additional testing.</p>

                <h3>Script Options</h3>
                <ul>
                    <li><code>--no-fail</code>: Prevents the script from returning a non-zero exit code when coverage is below the threshold</li>
                    <li><code>--include-test-helpers</code>: Includes test helper files in the coverage calculation (by default, test helpers are excluded)</li>
                </ul>

                <h3>Coverage Requirements</h3>
                <ul>
                    <li>Minimum coverage threshold: 80%</li>
                    <li>Critical components require 90%+ coverage:
                        <ul>
                            <li>Authentication mechanisms</li>
                            <li>Database connectivity</li>
                            <li>Core server initialization</li>
                        </ul>
                    </li>
                </ul>

                <h3>Error Handling</h3>
                <p>EpicServer provides comprehensive error handling for server initialization and database connections:</p>

                <div class="code-container">
                    <div class="code-header">Server Initialization Error Handling</div>
                    <pre><code class="language-go">// Create a new server instance
server := EpicServer.NewServer([]EpicServer.Option{
    EpicServer.SetSecretKey([]byte("your-secret-key")),
})

// Check for initialization errors
if server.HasErrors() {
    for _, err := range server.GetErrors() {
        fmt.Printf("Server initialization error: %v\n", err)
    }
    return
}

// Proceed with server configuration
server.UpdateAppLayer([]EpicServer.AppLayer{
    EpicServer.WithHealthCheck("/health"),
})

// Start the server
if err := server.Start(); err != nil {
    fmt.Printf("Server start error: %v\n", err)
    return
}</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">Database Connection Error Handling</div>
                    <pre><code class="language-go">// Get MongoDB client with error checking
client, ok := EpicServerDb.GetMongoClient(s, "default")
if !ok {
    // Handle error
    c.JSON(500, gin.H{"error": "Database connection failed"})
    return
}

// Get MongoDB collection with error checking
collection, err := EpicServerDb.GetMongoCollection(s, "default", "myapp", "users")
if err != nil {
    // Handle error
    c.JSON(500, gin.H{"error": "Collection not found"})
    return
}</code></pre>
                </div>
            </section>
        </article>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023 EpicServer. All rights reserved.</p>
            <p>
                <a href="https://github.com/tomskip123/EpicServer">GitHub</a> |
                <a href="https://github.com/tomskip123/EpicServer/issues">Issues</a> |
                <a href="https://github.com/tomskip123/EpicServer/blob/main/LICENSE">License</a>
            </p>
        </div>
    </footer>
</body>
</html> 