[{"content":"Core Architecture EpicServer is built on top of the Gin framework, providing a powerful and flexible foundation for building web applications in Go. The architecture is designed to be modular, extensible, and production-ready.\nKey Components Server: The central component that manages the HTTP server lifecycle and coordinates all other components. Router: Handles HTTP request routing and middleware management. Logger: Provides structured logging capabilities. Database Adapters: Connects to various database systems. Cache System: Provides in-memory caching capabilities. Authentication: Manages user authentication and session handling. Middleware: Processes requests before they reach route handlers. Server Lifecycle The server lifecycle consists of the following stages:\nInitialization: Create a new server instance with configuration options. Configuration: Apply additional configuration through app layers. Starting: Start the HTTP server and begin accepting connections. Running: Process incoming HTTP requests. Stopping: Gracefully shut down the server. // Initialization server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) // Configuration server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithHealthCheck(\u0026#34;/health\u0026#34;), EpicServer.WithEnvironment(\u0026#34;development\u0026#34;), }) // Starting server.Start() // Stopping (typically in a signal handler) server.Stop()\rConfiguration System EpicServer uses an options pattern for configuration, allowing for flexible and extensible configuration.\nOptions Pattern The options pattern allows for a clean and flexible way to configure the server:\nserver := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), })\rApp Layers App layers are used to add functionality to the server after initialization:\nserver.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithHealthCheck(\u0026#34;/health\u0026#34;), EpicServer.WithEnvironment(\u0026#34;development\u0026#34;), EpicServer.WithCors([]string{\u0026#34;https://example.com\u0026#34;}), })\rMiddleware Architecture Middleware in EpicServer follows a pipeline pattern, where each middleware can process the request before and after the next middleware or route handler.\nDefault Middleware EpicServer includes several default middleware components:\n// These are already applied by default defaultLayers := []AppLayer{ WithLoggerMiddleware(), // Add the logger to the context first WithHealthCheck(\u0026#34;/health\u0026#34;), WithCompression(), WithRemoveWWW(), WithEnvironment(config.Server.Environment), }\rCustom Middleware You can create custom middleware to add your own functionality:\nfunc MyCustomMiddleware() EpicServer.AppLayer { return func(s *EpicServer.Server) { s.Engine.Use(func(c *gin.Context) { // Pre-processing c.Set(\u0026#34;custom_key\u0026#34;, \u0026#34;custom_value\u0026#34;) c.Next() // Post-processing status := c.Writer.Status() if status \u0026gt;= 500 { s.Logger.Error(\u0026#34;Server error occurred\u0026#34;) } }) } }\rRouting System EpicServer\u0026rsquo;s routing system is built on top of Gin\u0026rsquo;s router, providing a flexible and powerful way to define routes.\nRoute Groups Routes can be organized into groups with common prefixes:\nEpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/users\u0026#34;, HandleGetUsers), EpicServer.Post(\u0026#34;/users\u0026#34;, HandleCreateUser), }, }, EpicServer.RouteGroup{ Prefix: \u0026#34;/admin\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/stats\u0026#34;, HandleAdminStats), }, }, )\rRoute Handlers Route handlers have access to both the Gin context and the server instance:\nfunc HandleGetUsers(c *gin.Context, s *EpicServer.Server) { // Access server components db := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) // Use gin context userId := c.Param(\u0026#34;id\u0026#34;) // Send response c.JSON(200, gin.H{\u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;}) }\rDatabase Architecture EpicServer supports multiple database adapters, allowing you to use different database systems in your application.\nDatabase Adapters MongoDB: Connect to MongoDB databases. PostgreSQL: Connect to PostgreSQL databases. MySQL: Connect to MySQL databases. GORM: Use GORM ORM with various database backends. Multiple Database Connections You can configure multiple database connections with different connection names:\nserver.UpdateAppLayer([]EpicServer.AppLayer{ // Configure multiple databases EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;users\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;users\u0026#34;, }), EpicServerDb.WithPostgres(EpicServerDb.PostgresConfig{ ConnectionName: \u0026#34;products\u0026#34;, Host: \u0026#34;localhost\u0026#34;, Database: \u0026#34;products\u0026#34;, }), })\rAuthentication System EpicServer provides a flexible authentication system supporting multiple providers and custom authentication hooks.\nAuthentication Providers Google: OAuth authentication with Google. Basic Auth: Username/password authentication. Custom Providers: Implement your own authentication providers. Authentication Hooks You can implement custom authentication hooks to integrate with your user management system:\ntype MyAuthHooks struct { db *Database } func (h *MyAuthHooks) OnUserCreate(user EpicServer.Claims) (string, error) { // Create user in database return userID, nil } func (h *MyAuthHooks) GetUserOrCreate(user EpicServer.Claims) (*EpicServer.CookieContents, error) { // Get or create user and return session data return \u0026amp;EpicServer.CookieContents{ UserId: user.UserID, Email: user.Email, SessionId: generateSessionID(), IsLoggedIn: true, ExpiresOn: time.Now().Add(time.Hour * 24), }, nil }\rLogging System EpicServer includes a structured logging system that provides rich logging capabilities.\nStructured Logging Structured logging allows for more detailed and machine-readable logs:\ns.Logger.Info(\u0026#34;User authenticated\u0026#34;, EpicServer.F(\u0026#34;user_id\u0026#34;, userID), EpicServer.F(\u0026#34;ip\u0026#34;, ip), EpicServer.F(\u0026#34;duration_ms\u0026#34;, authDuration.Milliseconds()))\rModule-Based Logging Module-based logging allows you to control log levels for specific components:\n// Set log level for specific modules s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogLevel(EpicServer.LogLevelInfo), EpicServer.WithModuleLogLevel(\u0026#34;auth\u0026#34;, EpicServer.LogLevelDebug), EpicServer.WithModuleLogLevel(\u0026#34;db\u0026#34;, EpicServer.LogLevelError), }) // Create module-specific loggers authLogger := s.Logger.WithModule(\u0026#34;auth\u0026#34;) dbLogger := s.Logger.WithModule(\u0026#34;db\u0026#34;)\rSecurity Architecture EpicServer includes several security features to help you build secure applications.\nSecurity Headers All responses automatically include security headers:\nX-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Strict-Transport-Security: max-age=31536000; includeSubDomains Content-Security-Policy: configurable CSRF Protection EpicServer includes CSRF protection to prevent cross-site request forgery attacks:\n// Enable CSRF protection server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithCSRFProtection(), }) // In your handlers func MyHandler(c *gin.Context) { // Generate CSRF token token, _ := EpicServer.GenerateCSRFToken() // Validate token in POST/PUT/DELETE requests if !EpicServer.IsTrustedSource(c.Request) { // Handle CSRF validation } }\rRate Limiting EpicServer includes rate limiting to prevent abuse:\n// Add rate limiting server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithRateLimiter(EpicServer.RateLimiterConfig{ MaxRequests: 100, Interval: time.Minute, BlockDuration: 5 * time.Minute, ExcludedPaths: []string{\u0026#34;/health\u0026#34;, \u0026#34;/static/*\u0026#34;}, }), })\r","date":"2023-09-07","id":0,"permalink":"/docs/concepts/architecture/","summary":"Learn about the core architecture and design principles behind EpicServer.","tags":[],"title":"Architecture"},{"content":"Complete API Example This example demonstrates how to build a complete API with EpicServer, including routing, database integration, and authentication.\nProject Structure myapi/ ├── main.go ├── go.mod ├── go.sum ├── handlers/ │ ├── users.go │ └── auth.go └── models/ └── user.go\rMain Application // main.go package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; \u0026#34;myapi/handlers\u0026#34; ) func main() { // Initialize server with options server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) // Configure server with app layers server.UpdateAppLayer([]EpicServer.AppLayer{ // Add MongoDB connection EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapi\u0026#34;, }), // Configure routes EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/users\u0026#34;, handlers.GetUsers), EpicServer.Get(\u0026#34;/users/:id\u0026#34;, handlers.GetUser), EpicServer.Post(\u0026#34;/users\u0026#34;, handlers.CreateUser), EpicServer.Put(\u0026#34;/users/:id\u0026#34;, handlers.UpdateUser), EpicServer.Delete(\u0026#34;/users/:id\u0026#34;, handlers.DeleteUser), }, }, ), // Add CORS support EpicServer.WithCors([]string{ \u0026#34;http://localhost:3000\u0026#34;, \u0026#34;https://myapp.example.com\u0026#34;, }), // Add authentication EpicServer.WithAuth([]EpicServer.Provider{ { Name: \u0026#34;google\u0026#34;, ClientId: \u0026#34;your-client-id\u0026#34;, ClientSecret: \u0026#34;your-client-secret\u0026#34;, Callback: \u0026#34;http://localhost:8080/auth/google/callback\u0026#34;, }, }, \u0026amp;EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: \u0026#34;localhost\u0026#34;, CookieSecure: false, CookieHTTPOnly: true, SessionDuration: time.Hour * 24, }), // Add authentication middleware EpicServer.WithAuthMiddleware(EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: \u0026#34;localhost\u0026#34;, CookieSecure: false, }), // Configure public paths that don\u0026#39;t require authentication EpicServer.WithPublicPaths(EpicServer.PublicPathConfig{ Exact: []string{ \u0026#34;/health\u0026#34;, \u0026#34;/api/v1/users\u0026#34;, }, Prefix: []string{ \u0026#34;/auth\u0026#34;, \u0026#34;/public\u0026#34;, }, }), }) // Start the server server.Start() }\rUser Model // models/user.go package models import ( \u0026#34;time\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; ) type User struct { ID primitive.ObjectID `bson:\u0026#34;_id,omitempty\u0026#34; json:\u0026#34;id\u0026#34;` Name string `bson:\u0026#34;name\u0026#34; json:\u0026#34;name\u0026#34;` Email string `bson:\u0026#34;email\u0026#34; json:\u0026#34;email\u0026#34;` CreatedAt time.Time `bson:\u0026#34;created_at\u0026#34; json:\u0026#34;created_at\u0026#34;` UpdatedAt time.Time `bson:\u0026#34;updated_at\u0026#34; json:\u0026#34;updated_at\u0026#34;` }\rUser Handlers // handlers/users.go package handlers import ( \u0026#34;context\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; \u0026#34;myapi/models\u0026#34; ) // GetUsers returns all users func GetUsers(c *gin.Context, s *EpicServer.Server) { // Get MongoDB client client, ok := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) if !ok { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Database connection failed\u0026#34;}) return } // Get users collection collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to access collection\u0026#34;}) return } // Find all users ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() cursor, err := collection.Find(ctx, bson.M{}) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } defer cursor.Close(ctx) // Decode users var users []models.User if err := cursor.All(ctx, \u0026amp;users); err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } c.JSON(http.StatusOK, users) } // GetUser returns a single user by ID func GetUser(c *gin.Context, s *EpicServer.Server) { // Get user ID from URL parameter id := c.Param(\u0026#34;id\u0026#34;) // Convert string ID to ObjectID objectID, err := primitive.ObjectIDFromHex(id) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid ID format\u0026#34;}) return } // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to access collection\u0026#34;}) return } // Find user by ID ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() var user models.User err = collection.FindOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}).Decode(\u0026amp;user) if err != nil { c.JSON(http.StatusNotFound, gin.H{\u0026#34;error\u0026#34;: \u0026#34;User not found\u0026#34;}) return } c.JSON(http.StatusOK, user) } // CreateUser creates a new user func CreateUser(c *gin.Context, s *EpicServer.Server) { // Parse request body var user models.User if err := c.ShouldBindJSON(\u0026amp;user); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Set timestamps now := time.Now() user.CreatedAt = now user.UpdatedAt = now // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to access collection\u0026#34;}) return } // Insert user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() result, err := collection.InsertOne(ctx, user) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Get inserted ID user.ID = result.InsertedID.(primitive.ObjectID) c.JSON(http.StatusCreated, user) } // UpdateUser updates an existing user func UpdateUser(c *gin.Context, s *EpicServer.Server) { // Get user ID from URL parameter id := c.Param(\u0026#34;id\u0026#34;) // Convert string ID to ObjectID objectID, err := primitive.ObjectIDFromHex(id) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid ID format\u0026#34;}) return } // Parse request body var user models.User if err := c.ShouldBindJSON(\u0026amp;user); err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Set update timestamp user.UpdatedAt = time.Now() // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to access collection\u0026#34;}) return } // Update user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() update := bson.M{ \u0026#34;$set\u0026#34;: bson.M{ \u0026#34;name\u0026#34;: user.Name, \u0026#34;email\u0026#34;: user.Email, \u0026#34;updated_at\u0026#34;: user.UpdatedAt, }, } result, err := collection.UpdateOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}, update) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if result.MatchedCount == 0 { c.JSON(http.StatusNotFound, gin.H{\u0026#34;error\u0026#34;: \u0026#34;User not found\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;User updated successfully\u0026#34;}) } // DeleteUser deletes a user func DeleteUser(c *gin.Context, s *EpicServer.Server) { // Get user ID from URL parameter id := c.Param(\u0026#34;id\u0026#34;) // Convert string ID to ObjectID objectID, err := primitive.ObjectIDFromHex(id) if err != nil { c.JSON(http.StatusBadRequest, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid ID format\u0026#34;}) return } // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to access collection\u0026#34;}) return } // Delete user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() result, err := collection.DeleteOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}) if err != nil { c.JSON(http.StatusInternalServerError, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } if result.DeletedCount == 0 { c.JSON(http.StatusNotFound, gin.H{\u0026#34;error\u0026#34;: \u0026#34;User not found\u0026#34;}) return } c.JSON(http.StatusOK, gin.H{\u0026#34;message\u0026#34;: \u0026#34;User deleted successfully\u0026#34;}) }\rAuthentication Hooks // handlers/auth.go package handlers import ( \u0026#34;context\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; \u0026#34;myapi/models\u0026#34; ) // AuthHooks implements the EpicServer.AuthHooks interface type AuthHooks struct { server *EpicServer.Server } // NewAuthHooks creates a new AuthHooks instance func NewAuthHooks(server *EpicServer.Server) *AuthHooks { return \u0026amp;AuthHooks{ server: server, } } // OnUserCreate is called when a new user is created during authentication func (h *AuthHooks) OnUserCreate(claims EpicServer.Claims) (string, error) { // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(h.server, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { return \u0026#34;\u0026#34;, err } // Create new user user := models.User{ Name: claims.Name, Email: claims.Email, CreatedAt: time.Now(), UpdatedAt: time.Now(), } // Insert user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() result, err := collection.InsertOne(ctx, user) if err != nil { return \u0026#34;\u0026#34;, err } // Return user ID return result.InsertedID.(primitive.ObjectID).Hex(), nil } // GetUserOrCreate is called during authentication to get or create a user func (h *AuthHooks) GetUserOrCreate(claims EpicServer.Claims) (*EpicServer.CookieContents, error) { // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(h.server, \u0026#34;default\u0026#34;, \u0026#34;myapi\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { return nil, err } // Try to find existing user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() var user models.User err = collection.FindOne(ctx, bson.M{\u0026#34;email\u0026#34;: claims.Email}).Decode(\u0026amp;user) // If user doesn\u0026#39;t exist, create a new one if err != nil { userID, err := h.OnUserCreate(claims) if err != nil { return nil, err } // Return session data return \u0026amp;EpicServer.CookieContents{ UserId: userID, Email: claims.Email, SessionId: primitive.NewObjectID().Hex(), IsLoggedIn: true, ExpiresOn: time.Now().Add(time.Hour * 24), }, nil } // Return session data for existing user return \u0026amp;EpicServer.CookieContents{ UserId: user.ID.Hex(), Email: user.Email, SessionId: primitive.NewObjectID().Hex(), IsLoggedIn: true, ExpiresOn: time.Now().Add(time.Hour * 24), }, nil }\rRegistering Auth Hooks Add this to your main.go:\n// Register auth hooks authHooks := handlers.NewAuthHooks(server) server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithAuthHooks(authHooks), })\rRunning the API To run the API:\ngo mod init myapi go mod tidy go run main.go\rThe API will be available at http://localhost:8080/api/v1/users.\n","date":"2023-09-07","id":1,"permalink":"/docs/examples/basic-api-example/","summary":"Learn how to build a complete API with EpicServer, including routing, database integration, and authentication.","tags":[],"title":"Basic API Example"},{"content":"The Getting Started section will guide you through installing and setting up EpicServer for your web application projects. Follow these guides to quickly get up and running with EpicServer\u0026rsquo;s powerful features.\n","date":"2023-09-07","id":2,"permalink":"/docs/getting-started/","summary":"Learn how to install and set up EpicServer for your web application.","tags":[],"title":"Getting Started"},{"content":"Prerequisites Before installing EpicServer, ensure you have:\nGo 1.16 or later installed A Go project initialized with Go modules Installation Add EpicServer to your project using Go modules:\ngo get github.com/tomskip123/EpicServer/v2\rThis will install the latest version of EpicServer in your project.\nNote: Version 2.x is the only supported version. Version 1.x is deprecated and should not be used for new projects.\nVerify Installation Verify the installation by checking your go.mod file. You should see EpicServer listed among your dependencies:\nrequire ( github.com/tomskip123/EpicServer/v2 v2.0.3 // other dependencies )\rBreaking Changes in v2.0.0 If you\u0026rsquo;re upgrading from v1.x to v2.x, be aware of these breaking changes:\nStructured logging replaces variadic logging Database connections now return errors instead of panicking Enhanced configuration system with validation Improved security features See the Migration Guide for detailed instructions on upgrading.\nNext Steps After installation, you can:\nFollow the Quick Start Guide to set up a basic server Learn about Core Concepts to understand EpicServer\u0026rsquo;s architecture Explore Examples to see EpicServer in action ","date":"2023-09-07","id":3,"permalink":"/docs/getting-started/installation/","summary":"Learn how to add EpicServer to your Go project using Go modules.","tags":[],"title":"Installation"},{"content":"Routing in EpicServer EpicServer provides a flexible routing system that allows you to organize your routes into groups and access server instance in your handlers.\nBasic Route Setup package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Configure routes EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/users\u0026#34;, HandleGetUsers), EpicServer.Post(\u0026#34;/users\u0026#34;, HandleCreateUser), EpicServer.Put(\u0026#34;/users/:id\u0026#34;, HandleUpdateUser), EpicServer.Delete(\u0026#34;/users/:id\u0026#34;, HandleDeleteUser), }, }, EpicServer.RouteGroup{ Prefix: \u0026#34;/admin\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/stats\u0026#34;, HandleAdminStats), }, }, ), }, }) server.Start() }\rRoute Handlers Route handlers have access to both the Gin context and the server instance:\nfunc HandleGetUsers(c *gin.Context, s *EpicServer.Server) { // Access server components db := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) cache := EpicServerCache.GetMemoryCache(s, \u0026#34;myCache\u0026#34;) // Use gin context as normal userId := c.Param(\u0026#34;id\u0026#34;) query := c.Query(\u0026#34;filter\u0026#34;) // Send response c.JSON(200, gin.H{\u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;}) }\rAvailable Route Methods Get(path string, handler HandlerFunc) - HTTP GET Post(path string, handler HandlerFunc) - HTTP POST Put(path string, handler HandlerFunc) - HTTP PUT Patch(path string, handler HandlerFunc) - HTTP PATCH Delete(path string, handler HandlerFunc) - HTTP DELETE Route Groups Group related routes with common prefix:\nEpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ // All routes here will be prefixed with /api/v1 }, }, )\rAccessing Server Components Route handlers can access all server components:\nfunc MyHandler(c *gin.Context, s *EpicServer.Server) { // Access configuration port := s.Config.Server.Port // Access logger s.Logger.Info(\u0026#34;Handling request\u0026#34;) // Access authentication session, _ := EpicServer.GetSession(c) // Access databases mongoClient := EpicServerDb.GetMongoClient(s, \u0026#34;mongodb\u0026#34;) postgresDB := EpicServerDb.GetPostgresDB(s, \u0026#34;postgres\u0026#34;) // Access cache cache := EpicServerCache.GetMemoryCache(s, \u0026#34;mycache\u0026#34;) // Access hooks s.Hooks.Auth.OnUserCreate(claims) }\rURL Parameters Access URL parameters using the Gin context:\nfunc HandleUser(c *gin.Context, s *EpicServer.Server) { // Get URL parameter userId := c.Param(\u0026#34;id\u0026#34;) // Use the parameter c.JSON(200, gin.H{\u0026#34;userId\u0026#34;: userId}) }\rQuery Parameters Access query parameters using the Gin context:\nfunc HandleUsers(c *gin.Context, s *EpicServer.Server) { // Get query parameters limit := c.DefaultQuery(\u0026#34;limit\u0026#34;, \u0026#34;10\u0026#34;) offset := c.DefaultQuery(\u0026#34;offset\u0026#34;, \u0026#34;0\u0026#34;) // Use the parameters c.JSON(200, gin.H{\u0026#34;limit\u0026#34;: limit, \u0026#34;offset\u0026#34;: offset}) }\rRequest Body Parse request body using the Gin context:\nfunc HandleCreateUser(c *gin.Context, s *EpicServer.Server) { // Define a struct for the request body var user struct { Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } // Parse the request body if err := c.ShouldBindJSON(\u0026amp;user); err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Use the parsed data c.JSON(200, gin.H{\u0026#34;name\u0026#34;: user.Name, \u0026#34;email\u0026#34;: user.Email}) }\r","date":"2023-09-07","id":4,"permalink":"/docs/guides/routing/","summary":"A comprehensive guide to setting up routes and handling requests in EpicServer.","tags":[],"title":"Routing"},{"content":"Server Options WithHealthCheck(path string) - Adds a health check endpoint WithCompression() - Enables response compression WithRemoveWWW() - Removes www prefix from domain WithCors(origins []string) - Configures CORS settings WithEnvironment(environment string) - Sets runtime environment (development/production/test) WithTrustedProxies(proxies []string) - Configures trusted proxy addresses WithHttp2() - Enables HTTP/2 support Configuration System EpicServer provides a flexible configuration system using options pattern.\nBasic Configuration package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) }\rAvailable Configuration Options The Config struct supports the following configurations:\ntype Config struct { Server struct { Host string Port int Environment string } Security struct { SecureCookie bool CookieDomain string CSPHeader string Origins []string } SecretKey []byte Custom interface{} }\rSetting Server Options Configure server host and port:\nEpicServer.SetHost(\u0026#34;0.0.0.0\u0026#34;, 3000)\rSetting Security Options Configure secret key for encryption:\nEpicServer.SetSecretKey([]byte(\u0026#34;32-byte-long-secret-key-here....\u0026#34;))\rDatabase Methods MongoDB specific helpers:\nStringToObjectID(id string) - Convert string to MongoDB ObjectID StringArrayToObjectIDArray(ids []string) - Convert string array to ObjectID array UpdateIndexes(ctx, collection, indexes) - Create or update collection indexes StringArrayContains(array []string, value string) - Check if string array contains value GORM specific helpers:\nAutoMigrateModels(s *EpicServer.Server, connectionName string, models ...interface{}) error - Run GORM AutoMigrate for the given models Cache Methods Set(key string, value interface{}, duration time.Duration) - Store a value with expiration Get(key string) (interface{}, bool) - Retrieve a value if it exists Delete(key string) - Remove a value from the cache Authentication Methods GenerateCSRFToken() (string, error) - Generate a CSRF token IsTrustedSource(req *http.Request) bool - Validate CSRF token GetSession(c *gin.Context) (*Session, error) - Retrieve session data Logging System Info(message string, args ...interface{}) - Logs an informational message Warn(message string, args ...interface{}) - Logs a warning message Error(message string, args ...interface{}) - Logs an error message Structured Logging Configuration // Configure log level s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogLevel(EpicServer.LogLevelDebug), }) // Configure log format s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogFormat(EpicServer.LogFormatJSON), }) // Log with structured fields s.Logger.Info(\u0026#34;User authenticated\u0026#34;, EpicServer.F(\u0026#34;user_id\u0026#34;, userID), EpicServer.F(\u0026#34;ip\u0026#34;, ip), EpicServer.F(\u0026#34;duration_ms\u0026#34;, authDuration.Milliseconds()))\rModule-Based Logging (v2.0.2+) EpicServer v2.0.2 introduces module-based logging, allowing you to control log levels for specific components of your application:\n// Set log level for specific modules s.UpdateAppLayer([]EpicServer.AppLayer{ // Set global default log level EpicServer.WithLogLevel(EpicServer.LogLevelInfo), // Enable debug logging only for authentication-related code EpicServer.WithModuleLogLevel(\u0026#34;auth\u0026#34;, EpicServer.LogLevelDebug), // Set error-only logging for database operations EpicServer.WithModuleLogLevel(\u0026#34;db\u0026#34;, EpicServer.LogLevelError), }) // Create module-specific loggers in your code authLogger := s.Logger.WithModule(\u0026#34;auth\u0026#34;) dbLogger := s.Logger.WithModule(\u0026#34;db\u0026#34;) // These logs will respect their module\u0026#39;s log level authLogger.Debug(\u0026#34;OAuth flow started\u0026#34;) // Will be logged (auth module is at Debug level) dbLogger.Debug(\u0026#34;Connection pool stats\u0026#34;) // Won\u0026#39;t be logged (db module is at Error level) dbLogger.Error(\u0026#34;Database connection failed\u0026#34;) // Will be logged // You can also use hierarchical module names authOAuthLogger := s.Logger.WithModule(\u0026#34;auth.oauth\u0026#34;) authBasicLogger := s.Logger.WithModule(\u0026#34;auth.basic\u0026#34;) // These will inherit from parent modules if no specific level is set // In this case, both inherit LogLevelDebug from the \u0026#34;auth\u0026#34; module\rModule-based logging features:\nHierarchical modules: Use dot notation (e.g., auth.oauth) to create a hierarchy of modules Inheritance: Modules inherit log levels from parent modules if not explicitly set Global registry: Module log levels are stored in a global registry by default Custom registries: Create isolated log level registries for more complex applications Advanced usage with custom registry:\n// Create a custom log registry registry := EpicServer.NewLogRegistry(EpicServer.LogLevelWarn) registry.SetLevel(\u0026#34;api\u0026#34;, EpicServer.LogLevelDebug) // Use the custom registry s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogRegistry(registry), }) // Or create a logger with a custom registry directly logger := EpicServer.NewLoggerWithRegistry(os.Stdout, EpicServer.LogLevelInfo, EpicServer.LogFormatText, registry)\r","date":"2023-09-07","id":5,"permalink":"/docs/reference/api-reference/","summary":"Detailed documentation of all EpicServer\u0026rsquo;s public API methods and types.","tags":[],"title":"API Reference"},{"content":"Middleware in EpicServer EpicServer provides several built-in middleware options and supports custom middleware creation.\nDefault Middleware EpicServer includes the following middleware by default:\n// These are already applied by default, you don\u0026#39;t need to add them manually defaultLayers := []AppLayer{ WithLoggerMiddleware(), // Add the logger to the context first WithHealthCheck(\u0026#34;/health\u0026#34;), WithCompression(), // Compression is already here! WithRemoveWWW(), WithEnvironment(config.Server.Environment), }\rCompression Middleware ⚠️ Important Note: Compression middleware is already included by default in the server initialization. You do not need to add it manually with WithCompression(). Adding it again will result in the middleware being applied twice, which can cause issues.\nIf you need to customize compression settings, you can replace the default middleware with your own implementation.\nfunc main() { // DO NOT add compression middleware like this unless you have a specific reason // as it\u0026#39;s already included by default: server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // EpicServer.WithCompression(), // This is redundant! Already included by default }, }) }\rFeatures:\nAutomatic gzip compression Smart cache control headers Asset-specific caching rules Conditional compression based on Accept-Encoding CORS Middleware Configure Cross-Origin Resource Sharing:\nfunc main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithCors([]string{ \u0026#34;https://example.com\u0026#34;, \u0026#34;https://api.example.com\u0026#34;, }), }, }) }\rFeatures:\nOrigin validation Configurable allowed origins Preflight request handling Custom headers support Credential support CSRF Protection Enable CSRF token validation:\nfunc main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithCSRFProtection(), }, }) } // In your handlers func MyHandler(c *gin.Context) { // Generate CSRF token token, _ := EpicServer.GenerateCSRFToken() // Validate token in POST/PUT/DELETE requests if !EpicServer.IsTrustedSource(c.Request) { // Handle CSRF validation } }\rFeatures:\nAutomatic token generation Token validation Trusted source bypass Custom token storage Header/Form support WWW Redirect Middleware Remove \u0026lsquo;www\u0026rsquo; prefix from domains:\nfunc main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithRemoveWWW(), }, }) }\rFeatures:\nAutomatic www detection Permanent redirects (301) HTTPS upgrade support Path preservation Custom Middleware Create your own middleware:\n⚠️ Important Note: When adding custom middleware, be aware of the default middleware that\u0026rsquo;s already included (WithLoggerMiddleware, WithHealthCheck, WithCompression, WithRemoveWWW, WithEnvironment). Avoid duplicating functionality that\u0026rsquo;s already provided by default middleware.\nfunc MyCustomMiddleware() EpicServer.AppLayer { return func(s *EpicServer.Server) { s.Engine.Use(func(c *gin.Context) { // Pre-processing c.Set(\u0026#34;custom_key\u0026#34;, \u0026#34;custom_value\u0026#34;) c.Next() // Post-processing status := c.Writer.Status() if status \u0026gt;= 500 { s.Logger.Error(\u0026#34;Server error occurred\u0026#34;) } }) } } // Usage server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ MyCustomMiddleware(), }, })\rMiddleware Order Middleware is executed in the order it\u0026rsquo;s added. Be aware that some middleware is already included by default (as shown in the Compression Middleware section).\n// Default middleware is applied first in this order: // 1. WithLoggerMiddleware() // 2. WithHealthCheck(\u0026#34;/health\u0026#34;) // 3. WithCompression() // 4. WithRemoveWWW() // 5. WithEnvironment(config.Server.Environment) // Then your custom middleware is applied: server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // DO NOT add middleware that\u0026#39;s already included by default // EpicServer.WithCompression(), // WRONG: Already included by default // DO add custom middleware you need EpicServer.WithCors(origins), // This will be 6th in execution order MyCustomMiddleware(), // This will be 7th in execution order }, })\rWhen adding your own middleware, remember that it will be executed after the default middleware. If you need to replace or customize default middleware, you should use a different approach (see Custom Configuration section).\nBuilt-in Security Headers All responses automatically include security headers:\nX-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Strict-Transport-Security: max-age=31536000; includeSubDomains Content-Security-Policy: configurable Replacing Default Middleware If you need to replace or customize default middleware (such as compression), you can create a custom server initialization that skips the default middleware:\n// Create a server without default middleware server := \u0026amp;EpicServer.Server{ Config: EpicServer.defaultConfig(), Engine: gin.New(), // Use gin.New() instead of gin.Default() to avoid default middleware } // Initialize the logger server.Logger = EpicServer.defaultLogger(os.Stdout) // Setup default hooks server.Hooks = EpicServer.defaultHooks(server) // Add only the middleware you want server.Engine.Use(EpicServer.LoggerMiddleware(server.Logger)) server.Engine.Use(EpicServer.RequestTimingMiddleware(server.Logger)) server.Engine.Use(MyCustomCompressMiddleware()) // Your custom compression middleware server.Engine.Use(EpicServer.RemoveWWWMiddleware()) // Continue with your custom configuration // ...\rThis approach gives you full control over which middleware is included and in what order.\n","date":"2023-09-07","id":6,"permalink":"/docs/guides/middleware/","summary":"A comprehensive guide to using built-in middleware and creating custom middleware in EpicServer.","tags":[],"title":"Middleware"},{"content":"Important Note on Versions Version 2.x is now the only supported version of EpicServer. Version 1.x is deprecated and will not receive updates or security patches. All users are strongly encouraged to migrate to v2.x as soon as possible.\nTo install the latest v2 version:\ngo get github.com/tomskip123/EpicServer/v2\rUpgrading to v2.0.0 Version 2.0.0 introduces several breaking changes to improve error handling, security, and maintainability. Follow this guide to update your application.\n1. Logger Interface Changes The logging system has been completely refactored to support structured logging:\n// OLD (pre-v2.0.0) s.Logger.Info(\u0026#34;Connected to database\u0026#34;, dbName) // NEW (v2.0.0+) s.Logger.Info(\u0026#34;Connected to database\u0026#34;, F(\u0026#34;name\u0026#34;, dbName))\rAll logger methods now accept a message string and a variable number of LogField objects. Use the F() helper function to create these fields.\n2. MongoDB Interface Changes Database connections no longer panic on failure and return more information:\n// OLD (pre-v2.0.0) client := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) collection := client.Database(\u0026#34;myapp\u0026#34;).Collection(\u0026#34;users\u0026#34;) // NEW (v2.0.0+) client, ok := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) if !ok { // Handle error return } collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { // Handle error return }\r3. Server Initialization Error Handling Server initialization now captures errors instead of panicking:\n// OLD (pre-v2.0.0) server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) // If configuration is invalid, this would panic server.Start() // NEW (v2.0.0+) server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) if server.HasErrors() { for _, err := range server.GetErrors() { fmt.Printf(\u0026#34;Server initialization error: %v\\n\u0026#34;, err) } return } server.Start()\r4. Memory Cache Configuration Memory cache now requires additional configuration parameters:\n// OLD (pre-v2.0.0) s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServerCache.WithMemoryCache(\u0026amp;EpicServerCache.MemoryCacheConfig{ Name: \u0026#34;default\u0026#34;, Type: \u0026#34;memory\u0026#34;, }), }) // NEW (v2.0.0+) s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServerCache.WithMemoryCache(\u0026amp;EpicServerCache.MemoryCacheConfig{ Name: \u0026#34;default\u0026#34;, Type: \u0026#34;memory\u0026#34;, DefaultTTL: 5 * time.Minute, CleanupInterval: time.Minute, MaxItems: 1000, // Optional }), })\rNew Features Usage Environment Variables Configuration // Load configuration from environment variables server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.WithEnvVars(), // Provide fallback values for critical settings EpicServer.SetSecretKey([]byte(\u0026#34;fallback-secret-key\u0026#34;)), })\rAvailable environment variables:\nEPICSERVER_SERVER_HOST: Server host EPICSERVER_SERVER_PORT: Server port EPICSERVER_SERVER_ENVIRONMENT: Environment name EPICSERVER_SECURITY_SECURECOOKIE: Enable secure cookies (true/false) EPICSERVER_SECURITY_COOKIEDOMAIN: Cookie domain EPICSERVER_SECURITY_CSPHEADER: Content Security Policy header EPICSERVER_SECURITY_ORIGINS: Comma-separated CORS origins EPICSERVER_SECRETKEY: Secret key for encryption/signing Rate Limiting // Add rate limiting to your server import ( \u0026#34;time\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) // Later in your code: s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithRateLimiter(EpicServer.RateLimiterConfig{ MaxRequests: 100, Interval: time.Minute, BlockDuration: 5 * time.Minute, ExcludedPaths: []string{\u0026#34;/health\u0026#34;, \u0026#34;/static/*\u0026#34;}, }), })\rSecurity Headers // Add recommended security headers to all responses s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithSecurityHeaders(nil), // Use defaults }) // Or with custom configuration s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithSecurityHeaders(\u0026amp;EpicServer.SecurityHeadersConfig{ EnableHSTS: true, HSTSMaxAge: 63072000, // 2 years ContentSecurityPolicy: \u0026#34;default-src \u0026#39;self\u0026#39;\u0026#34;, }), })\rStructured Logging Configuration // Configure log level s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogLevel(EpicServer.LogLevelDebug), }) // Configure log format s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogFormat(EpicServer.LogFormatJSON), }) // Log with structured fields s.Logger.Info(\u0026#34;User authenticated\u0026#34;, EpicServer.F(\u0026#34;user_id\u0026#34;, userID), EpicServer.F(\u0026#34;ip\u0026#34;, ip), EpicServer.F(\u0026#34;duration_ms\u0026#34;, authDuration.Milliseconds()))\rModule-Based Logging (v2.0.2+) EpicServer v2.0.2 introduces module-based logging, allowing you to control log levels for specific components of your application:\n// Set log level for specific modules s.UpdateAppLayer([]EpicServer.AppLayer{ // Set global default log level EpicServer.WithLogLevel(EpicServer.LogLevelInfo), // Enable debug logging only for authentication-related code EpicServer.WithModuleLogLevel(\u0026#34;auth\u0026#34;, EpicServer.LogLevelDebug), // Set error-only logging for database operations EpicServer.WithModuleLogLevel(\u0026#34;db\u0026#34;, EpicServer.LogLevelError), }) // Create module-specific loggers in your code authLogger := s.Logger.WithModule(\u0026#34;auth\u0026#34;) dbLogger := s.Logger.WithModule(\u0026#34;db\u0026#34;) // These logs will respect their module\u0026#39;s log level authLogger.Debug(\u0026#34;OAuth flow started\u0026#34;) // Will be logged (auth module is at Debug level) dbLogger.Debug(\u0026#34;Connection pool stats\u0026#34;) // Won\u0026#39;t be logged (db module is at Error level) dbLogger.Error(\u0026#34;Database connection failed\u0026#34;) // Will be logged // You can also use hierarchical module names authOAuthLogger := s.Logger.WithModule(\u0026#34;auth.oauth\u0026#34;) authBasicLogger := s.Logger.WithModule(\u0026#34;auth.basic\u0026#34;) // These will inherit from parent modules if no specific level is set // In this case, both inherit LogLevelDebug from the \u0026#34;auth\u0026#34; module\rModule-based logging features:\nHierarchical modules: Use dot notation (e.g., auth.oauth) to create a hierarchy of modules Inheritance: Modules inherit log levels from parent modules if not explicitly set Global registry: Module log levels are stored in a global registry by default Custom registries: Create isolated log level registries for more complex applications Advanced usage with custom registry:\n// Create a custom log registry registry := EpicServer.NewLogRegistry(EpicServer.LogLevelWarn) registry.SetLevel(\u0026#34;api\u0026#34;, EpicServer.LogLevelDebug) // Use the custom registry s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithLogRegistry(registry), }) // Or create a logger with a custom registry directly logger := EpicServer.NewLoggerWithRegistry(os.Stdout, EpicServer.LogLevelInfo, EpicServer.LogFormatText, registry)\r","date":"2023-09-07","id":7,"permalink":"/docs/reference/migration-guide/","summary":"Learn how to upgrade your application from EpicServer v1.x to v2.x.","tags":[],"title":"Migration Guide"},{"content":"This quick start guide will help you create a simple web server using EpicServer. By the end, you\u0026rsquo;ll have a working HTTP server with basic routing and logging.\nCreate a New Project First, create a new directory for your project and initialize a Go module:\nmkdir myepicserver cd myepicserver go mod init myepicserver\rInstall EpicServer Add EpicServer to your project:\ngo get github.com/tomskip123/EpicServer/v2\rCreate a Basic Server Create a file named main.go with the following content:\npackage main import \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithHealthCheck(\u0026#34;/health\u0026#34;), EpicServer.WithEnvironment(\u0026#34;development\u0026#34;), }) server.Start() }\rThis creates a minimal server with a health check endpoint and sets the environment to development.\nComplete Example Here\u0026rsquo;s a more complete example with routing, database, and authentication:\npackage main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/users\u0026#34;, HandleUsers), }, }, ), EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapp\u0026#34;, }), }) server.Start() } func HandleUsers(c *gin.Context, s *EpicServer.Server) { client := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) db := client.Database(\u0026#34;myapp\u0026#34;) collection := db.Collection(\u0026#34;users\u0026#34;) // Handle request using MongoDB... c.JSON(200, gin.H{\u0026#34;message\u0026#34;: \u0026#34;users endpoint\u0026#34;}) }\rRun Your Server Run your server with:\ngo run main.go\rVisit http://localhost:8080/health in your browser or use curl to check if your server is running:\ncurl http://localhost:8080/health\rYou should see a response indicating the server is healthy.\nNext Steps Now that you have a basic server running, you can:\nLearn about Routing to add more endpoints Set up Middleware for request processing Explore Database Support for your application Implement Authentication for secure access ","date":"2023-09-07","id":8,"permalink":"/docs/getting-started/quick-start/","summary":"A step-by-step guide to create your first EpicServer application.","tags":[],"title":"Quick Start"},{"content":"This section provides detailed explanations of the core concepts and architecture that power EpicServer. Understanding these concepts will help you make better design decisions and get the most out of EpicServer.\n","date":"2023-09-07","id":9,"permalink":"/docs/concepts/","summary":"Deep dive into the core concepts and architecture that power EpicServer.","tags":[],"title":"Core Concepts"},{"content":"Database Support in EpicServer EpicServer supports multiple database adapters out of the box, allowing you to connect to various database systems.\nMongoDB package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ // Configure MongoDB EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapp\u0026#34;, }), }) server.Start() } func HandleUsers(c *gin.Context, s *EpicServer.Server) { client := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) db := client.Database(\u0026#34;myapp\u0026#34;) collection := db.Collection(\u0026#34;users\u0026#34;) // Handle request using MongoDB... }\rPostgreSQL package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ // Configure PostgreSQL EpicServerDb.WithPostgres(EpicServerDb.PostgresConfig{ ConnectionName: \u0026#34;default\u0026#34;, Host: \u0026#34;localhost\u0026#34;, Port: 5432, User: \u0026#34;postgres\u0026#34;, Password: \u0026#34;password\u0026#34;, Database: \u0026#34;myapp\u0026#34;, SSLMode: \u0026#34;disable\u0026#34;, }), }) server.Start() } func HandleUsers(c *gin.Context, s *EpicServer.Server) { db := EpicServerDb.GetPostgresDB(s, \u0026#34;default\u0026#34;) // Handle request using PostgreSQL... }\rMySQL package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ // Configure MySQL EpicServerDb.WithMySQL(EpicServerDb.MySQLConfig{ ConnectionName: \u0026#34;default\u0026#34;, Host: \u0026#34;localhost\u0026#34;, Port: 3306, User: \u0026#34;root\u0026#34;, Password: \u0026#34;password\u0026#34;, Database: \u0026#34;myapp\u0026#34;, }), }) server.Start() } func HandleUsers(c *gin.Context, s *EpicServer.Server) { db := EpicServerDb.GetMySQLDB(s, \u0026#34;default\u0026#34;) // Handle request using MySQL... }\rGORM package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ // Configure GORM EpicServerDb.WithGorm(\u0026amp;EpicServerDb.GormConfig{ ConnectionName: \u0026#34;default\u0026#34;, Dialect: \u0026#34;mysql\u0026#34;, // \u0026#34;mysql\u0026#34;, \u0026#34;postgres\u0026#34;, or \u0026#34;sqlite\u0026#34; DSN: \u0026#34;user:password@tcp(localhost:3306)/dbname\u0026#34;, }), }) server.Start() } func HandleUsers(c *gin.Context, s *EpicServer.Server) { db := EpicServerDb.GetGormDB(s, \u0026#34;default\u0026#34;) // Handle request using GORM... }\rMultiple Database Connections You can configure multiple database connections with different connection names:\nserver := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) server.UpdateAppLayer([]EpicServer.AppLayer{ // Configure multiple databases EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;users\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;users\u0026#34;, }), EpicServerDb.WithPostgres(EpicServerDb.PostgresConfig{ ConnectionName: \u0026#34;products\u0026#34;, Host: \u0026#34;localhost\u0026#34;, Port: 5432, User: \u0026#34;postgres\u0026#34;, Password: \u0026#34;password\u0026#34;, Database: \u0026#34;products\u0026#34;, SSLMode: \u0026#34;disable\u0026#34;, }), EpicServerDb.WithMySQL(EpicServerDb.MySQLConfig{ ConnectionName: \u0026#34;orders\u0026#34;, Host: \u0026#34;localhost\u0026#34;, Port: 3306, User: \u0026#34;root\u0026#34;, Password: \u0026#34;password\u0026#34;, Database: \u0026#34;orders\u0026#34;, }), })\rError Handling In EpicServer v2.0.0 and later, database connections return errors instead of panicking:\n// Get MongoDB client with error checking client, ok := EpicServerDb.GetMongoClient(s, \u0026#34;default\u0026#34;) if !ok { // Handle error c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Database connection failed\u0026#34;}) return } // Get MongoDB collection with error checking collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { // Handle error c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to access collection\u0026#34;}) return }\rDatabase Helper Functions EpicServer provides several helper functions for working with databases:\nMongoDB Helpers // Convert string to MongoDB ObjectID id := EpicServerDb.StringToObjectID(\u0026#34;5f8a7b6c5d4e3f2a1b0c9d8e\u0026#34;) // Convert string array to ObjectID array ids := EpicServerDb.StringArrayToObjectIDArray([]string{\u0026#34;5f8a7b6c5d4e3f2a1b0c9d8e\u0026#34;, \u0026#34;5f8a7b6c5d4e3f2a1b0c9d8f\u0026#34;}) // Create or update collection indexes indexes := []mongo.IndexModel{ { Keys: bson.D{{Key: \u0026#34;email\u0026#34;, Value: 1}}, Options: options.Index().SetUnique(true), }, } err := EpicServerDb.UpdateIndexes(ctx, collection, indexes)\rGORM Helpers // Auto migrate models err := EpicServerDb.AutoMigrateModels(s, \u0026#34;default\u0026#34;, \u0026amp;User{}, \u0026amp;Product{}, \u0026amp;Order{}) if err != nil { // Handle error }\r","date":"2023-09-07","id":10,"permalink":"/docs/guides/database-support/","summary":"A comprehensive guide to using different database adapters in EpicServer.","tags":[],"title":"Database Support"},{"content":"This section contains in-depth guides on how to use EpicServer\u0026rsquo;s various features. These guides provide detailed explanations and examples to help you make the most of EpicServer in your applications.\n","date":"2023-09-07","id":11,"permalink":"/docs/guides/","summary":"Detailed guides on how to use various features of EpicServer.","tags":[],"title":"Guides"},{"content":"This section provides practical code examples and sample projects to help you learn how to use EpicServer effectively. These examples cover common use cases and best practices for building web applications and APIs with EpicServer.\n","date":"2023-09-07","id":12,"permalink":"/docs/examples/","summary":"Practical examples and sample projects to help you learn EpicServer.","tags":[],"title":"Examples"},{"content":"Authentication in EpicServer EpicServer provides a flexible authentication system supporting multiple providers and custom authentication hooks.\nSetting Up Authentication package main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Configure authentication EpicServer.WithAuth([]EpicServer.Provider{ { Name: \u0026#34;google\u0026#34;, ClientId: \u0026#34;your-client-id\u0026#34;, ClientSecret: \u0026#34;your-client-secret\u0026#34;, Callback: \u0026#34;http://localhost:3000/auth/google/callback\u0026#34;, }, }, \u0026amp;EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: \u0026#34;localhost\u0026#34;, CookieSecure: false, CookieHTTPOnly: true, SessionDuration: time.Hour * 24, }), // Add authentication middleware EpicServer.WithAuthMiddleware(EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: \u0026#34;localhost\u0026#34;, CookieSecure: false, }), }, }) server.Start() }\rConfiguring Public Paths Define paths that don\u0026rsquo;t require authentication:\nEpicServer.WithPublicPaths(EpicServer.PublicPathConfig{ Exact: []string{ \u0026#34;/health\u0026#34;, \u0026#34;/login\u0026#34;, }, Prefix: []string{ \u0026#34;/public\u0026#34;, \u0026#34;/api/v1/public\u0026#34;, }, })\rCustom Authentication Hooks Implement custom authentication logic:\ntype MyAuthHooks struct { db *Database } func (h *MyAuthHooks) OnUserCreate(user EpicServer.Claims) (string, error) { // Create user in database return userID, nil } func (h *MyAuthHooks) GetUserOrCreate(user EpicServer.Claims) (*EpicServer.CookieContents, error) { // Get or create user and return session data return \u0026amp;EpicServer.CookieContents{ UserId: user.UserID, Email: user.Email, SessionId: generateSessionID(), IsLoggedIn: true, ExpiresOn: time.Now().Add(time.Hour * 24), }, nil } // Add auth hooks to server server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithAuthHooks(\u0026amp;MyAuthHooks{db: db}), })\rAvailable Auth Providers Google (\u0026quot;google\u0026quot;) Basic Auth (\u0026quot;basic\u0026quot;) Custom providers can be added by implementing the provider interface Environment Variables Required environment variables for secure authentication:\nSECURE_COOKIE_HASH_KEY=base64_encoded_32_byte_key SECURE_COOKIE_BLOCK_KEY=base64_encoded_32_byte_key ENCRYPTION_KEY=32_byte_hex_encoded_key\rGenerate secure keys using:\nhashKey, _ := EpicServer.GenerateEncryptionKey() blockKey, _ := EpicServer.GenerateEncryptionKey()\rAuthentication Endpoints The following endpoints are automatically created:\n/auth/:provider - Initiates authentication flow /auth/:provider/callback - OAuth callback URL /auth/logout - Handles user logout Session Management Access session data in your handlers:\nfunc MyProtectedHandler(c *gin.Context) { session, err := EpicServer.GetSession(c) if err != nil { c.AbortWithStatus(401) return } // Access session data userEmail := session.Email userData := session.User }\rSecurity Features CSRF Protection Enable CSRF token validation:\nfunc main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithCSRFProtection(), }, }) } // In your handlers func MyHandler(c *gin.Context) { // Generate CSRF token token, _ := EpicServer.GenerateCSRFToken() // Validate token in POST/PUT/DELETE requests if !EpicServer.IsTrustedSource(c.Request) { // Handle CSRF validation } }\rSecurity Headers All responses automatically include security headers:\nX-Content-Type-Options: nosniff X-Frame-Options: DENY X-XSS-Protection: 1; mode=block Strict-Transport-Security: max-age=31536000; includeSubDomains Content-Security-Policy: configurable Rate Limiting EpicServer includes a built-in rate limiter to prevent abuse:\n// Add rate limiting to your server import ( \u0026#34;time\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) // Later in your code: s.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithRateLimiter(EpicServer.RateLimiterConfig{ MaxRequests: 100, Interval: time.Minute, BlockDuration: 5 * time.Minute, ExcludedPaths: []string{\u0026#34;/health\u0026#34;, \u0026#34;/static/*\u0026#34;}, }), })\rComplete Authentication Example Here\u0026rsquo;s a complete example with MongoDB integration:\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; ) // User model type User struct { ID primitive.ObjectID `bson:\u0026#34;_id,omitempty\u0026#34; json:\u0026#34;id\u0026#34;` Email string `bson:\u0026#34;email\u0026#34; json:\u0026#34;email\u0026#34;` Name string `bson:\u0026#34;name\u0026#34; json:\u0026#34;name\u0026#34;` CreatedAt time.Time `bson:\u0026#34;created_at\u0026#34; json:\u0026#34;created_at\u0026#34;` } // AuthHooks implements the EpicServer.AuthHooks interface type AuthHooks struct { server *EpicServer.Server } // OnUserCreate is called when a new user is created during authentication func (h *AuthHooks) OnUserCreate(claims EpicServer.Claims) (string, error) { // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(h.server, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { return \u0026#34;\u0026#34;, err } // Create new user user := User{ Email: claims.Email, Name: claims.Name, CreatedAt: time.Now(), } // Insert user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() result, err := collection.InsertOne(ctx, user) if err != nil { return \u0026#34;\u0026#34;, err } // Return user ID return result.InsertedID.(primitive.ObjectID).Hex(), nil } // GetUserOrCreate is called during authentication to get or create a user func (h *AuthHooks) GetUserOrCreate(claims EpicServer.Claims) (*EpicServer.CookieContents, error) { // Get MongoDB collection collection, err := EpicServerDb.GetMongoCollection(h.server, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { return nil, err } // Try to find existing user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() var user User err = collection.FindOne(ctx, bson.M{\u0026#34;email\u0026#34;: claims.Email}).Decode(\u0026amp;user) // If user doesn\u0026#39;t exist, create a new one if err != nil { userID, err := h.OnUserCreate(claims) if err != nil { return nil, err } // Return session data return \u0026amp;EpicServer.CookieContents{ UserId: userID, Email: claims.Email, SessionId: primitive.NewObjectID().Hex(), IsLoggedIn: true, ExpiresOn: time.Now().Add(time.Hour * 24), }, nil } // Return session data for existing user return \u0026amp;EpicServer.CookieContents{ UserId: user.ID.Hex(), Email: user.Email, SessionId: primitive.NewObjectID().Hex(), IsLoggedIn: true, ExpiresOn: time.Now().Add(time.Hour * 24), }, nil } func main() { // Initialize server server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), EpicServer.SetSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }) // Create auth hooks authHooks := \u0026amp;AuthHooks{server: server} // Configure server server.UpdateAppLayer([]EpicServer.AppLayer{ // Add MongoDB connection EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapp\u0026#34;, }), // Configure authentication EpicServer.WithAuth([]EpicServer.Provider{ { Name: \u0026#34;google\u0026#34;, ClientId: \u0026#34;your-client-id\u0026#34;, ClientSecret: \u0026#34;your-client-secret\u0026#34;, Callback: \u0026#34;http://localhost:8080/auth/google/callback\u0026#34;, }, }, \u0026amp;EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: \u0026#34;localhost\u0026#34;, CookieSecure: false, CookieHTTPOnly: true, SessionDuration: time.Hour * 24, }), // Add authentication middleware EpicServer.WithAuthMiddleware(EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: \u0026#34;localhost\u0026#34;, CookieSecure: false, }), // Add auth hooks EpicServer.WithAuthHooks(authHooks), // Configure public paths EpicServer.WithPublicPaths(EpicServer.PublicPathConfig{ Exact: []string{ \u0026#34;/health\u0026#34;, }, Prefix: []string{ \u0026#34;/auth\u0026#34;, \u0026#34;/public\u0026#34;, }, }), // Add CSRF protection EpicServer.WithCSRFProtection(), // Add routes EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/profile\u0026#34;, HandleProfile), }, }, ), }) // Start the server server.Start() } // HandleProfile returns the user\u0026#39;s profile func HandleProfile(c *gin.Context, s *EpicServer.Server) { // Get session session, err := EpicServer.GetSession(c) if err != nil { c.JSON(401, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Unauthorized\u0026#34;}) return } // Get user from database collection, err := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) if err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Database error\u0026#34;}) return } // Convert user ID to ObjectID userID, err := primitive.ObjectIDFromHex(session.UserId) if err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid user ID\u0026#34;}) return } // Find user ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() var user User err = collection.FindOne(ctx, bson.M{\u0026#34;_id\u0026#34;: userID}).Decode(\u0026amp;user) if err != nil { c.JSON(404, gin.H{\u0026#34;error\u0026#34;: \u0026#34;User not found\u0026#34;}) return } // Return user profile c.JSON(200, user) }\r","date":"2023-09-07","id":13,"permalink":"/docs/guides/authentication/","summary":"A comprehensive guide to setting up authentication in EpicServer.","tags":[],"title":"Authentication"},{"content":"This section provides detailed technical reference documentation for EpicServer\u0026rsquo;s API and components. It\u0026rsquo;s designed to help developers understand the full capabilities of EpicServer and how to use them effectively.\n","date":"2023-09-07","id":14,"permalink":"/docs/reference/","summary":"Detailed reference documentation for EpicServer\u0026rsquo;s API and components.","tags":[],"title":"Reference"},{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":15,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":16,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"Caching in EpicServer EpicServer provides built-in caching support with both in-memory and Redis cache providers. This guide will show you how to configure and use caching in your applications.\nSetting Up In-Memory Cache The in-memory cache is the simplest way to add caching to your application:\npackage main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Configure in-memory cache EpicServer.WithMemoryCache(\u0026amp;EpicServer.MemoryCacheConfig{ DefaultExpiration: 5 * time.Minute, CleanupInterval: 10 * time.Minute, ConnectionName: \u0026#34;default\u0026#34;, }), }, }) server.Start() }\rSetting Up Redis Cache For distributed applications, Redis cache is recommended:\npackage main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Configure Redis cache EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;default\u0026#34;, Address: \u0026#34;localhost:6379\u0026#34;, Password: \u0026#34;\u0026#34;, DB: 0, }), }, }) server.Start() }\rMultiple Cache Connections You can configure multiple cache connections with different names:\n// Configure multiple cache connections server.UpdateAppLayer([]EpicServer.AppLayer{ // In-memory cache for session data EpicServer.WithMemoryCache(\u0026amp;EpicServer.MemoryCacheConfig{ DefaultExpiration: 30 * time.Minute, CleanupInterval: 1 * time.Hour, ConnectionName: \u0026#34;sessions\u0026#34;, }), // Redis cache for API responses EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;api\u0026#34;, Address: \u0026#34;localhost:6379\u0026#34;, Password: \u0026#34;\u0026#34;, DB: 1, }), })\rUsing Cache in Your Application Basic Cache Operations // Get cache client cache, err := server.GetCache(\u0026#34;default\u0026#34;) if err != nil { // Handle error } // Set a value with default expiration err = cache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;, 0) if err != nil { // Handle error } // Set a value with custom expiration err = cache.Set(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;, 5*time.Minute) if err != nil { // Handle error } // Get a value var value string found, err := cache.Get(\u0026#34;key\u0026#34;, \u0026amp;value) if err != nil { // Handle error } if found { // Use value } // Delete a value err = cache.Delete(\u0026#34;key\u0026#34;) if err != nil { // Handle error }\rCaching in Route Handlers func GetUserHandler(c *gin.Context, s *EpicServer.Server) { userID := c.Param(\u0026#34;id\u0026#34;) cacheKey := \u0026#34;user:\u0026#34; + userID // Try to get from cache first cache, _ := s.GetCache(\u0026#34;default\u0026#34;) var user User found, _ := cache.Get(cacheKey, \u0026amp;user) if found { // Return cached user c.JSON(200, user) return } // Get from database if not in cache collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() objectID, _ := primitive.ObjectIDFromHex(userID) err := collection.FindOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}).Decode(\u0026amp;user) if err != nil { c.JSON(404, gin.H{\u0026#34;error\u0026#34;: \u0026#34;User not found\u0026#34;}) return } // Store in cache for future requests cache.Set(cacheKey, user, 5*time.Minute) // Return user c.JSON(200, user) }\rCache Invalidation func UpdateUserHandler(c *gin.Context, s *EpicServer.Server) { userID := c.Param(\u0026#34;id\u0026#34;) var updateData User if err := c.ShouldBindJSON(\u0026amp;updateData); err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Update in database collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;users\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() objectID, _ := primitive.ObjectIDFromHex(userID) update := bson.M{ \u0026#34;$set\u0026#34;: bson.M{ \u0026#34;name\u0026#34;: updateData.Name, \u0026#34;updated_at\u0026#34;: time.Now(), }, } _, err := collection.UpdateOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}, update) if err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to update user\u0026#34;}) return } // Invalidate cache cache, _ := s.GetCache(\u0026#34;default\u0026#34;) cache.Delete(\u0026#34;user:\u0026#34; + userID) c.JSON(200, gin.H{\u0026#34;message\u0026#34;: \u0026#34;User updated successfully\u0026#34;}) }\rAdvanced Caching Techniques Caching with TTL (Time-To-Live) // Cache with 1 hour TTL cache.Set(\u0026#34;long-lived-data\u0026#34;, data, time.Hour) // Cache with 30 seconds TTL cache.Set(\u0026#34;short-lived-data\u0026#34;, data, 30*time.Second) // Cache with default TTL (from config) cache.Set(\u0026#34;default-ttl-data\u0026#34;, data, 0)\rBatch Operations // Get multiple values keys := []string{\u0026#34;key1\u0026#34;, \u0026#34;key2\u0026#34;, \u0026#34;key3\u0026#34;} values := make(map[string]interface{}) for _, key := range keys { var value interface{} found, _ := cache.Get(key, \u0026amp;value) if found { values[key] = value } } // Delete multiple values for _, key := range keys { cache.Delete(key) }\rCaching Complex Objects type ComplexObject struct { ID string Name string CreatedAt time.Time Data map[string]interface{} Items []Item } type Item struct { ID string Value int } // Cache complex object obj := ComplexObject{ ID: \u0026#34;123\u0026#34;, Name: \u0026#34;Test Object\u0026#34;, CreatedAt: time.Now(), Data: map[string]interface{}{ \u0026#34;key1\u0026#34;: \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34;: 42, }, Items: []Item{ {ID: \u0026#34;item1\u0026#34;, Value: 10}, {ID: \u0026#34;item2\u0026#34;, Value: 20}, }, } cache.Set(\u0026#34;complex:123\u0026#34;, obj, time.Hour) // Retrieve complex object var retrieved ComplexObject found, _ := cache.Get(\u0026#34;complex:123\u0026#34;, \u0026amp;retrieved) if found { // Use retrieved object }\rComplete Caching Example Here\u0026rsquo;s a complete example with Redis cache and MongoDB integration:\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; ) // Product model type Product struct { ID primitive.ObjectID `bson:\u0026#34;_id,omitempty\u0026#34; json:\u0026#34;id\u0026#34;` Name string `bson:\u0026#34;name\u0026#34; json:\u0026#34;name\u0026#34;` Description string `bson:\u0026#34;description\u0026#34; json:\u0026#34;description\u0026#34;` Price float64 `bson:\u0026#34;price\u0026#34; json:\u0026#34;price\u0026#34;` CreatedAt time.Time `bson:\u0026#34;created_at\u0026#34; json:\u0026#34;created_at\u0026#34;` UpdatedAt time.Time `bson:\u0026#34;updated_at\u0026#34; json:\u0026#34;updated_at\u0026#34;` } func main() { // Initialize server server := EpicServer.NewServer([]EpicServer.Option{ EpicServer.SetHost(\u0026#34;localhost\u0026#34;, 8080), }) // Configure server server.UpdateAppLayer([]EpicServer.AppLayer{ // Add MongoDB connection EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapp\u0026#34;, }), // Add Redis cache EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;default\u0026#34;, Address: \u0026#34;localhost:6379\u0026#34;, Password: \u0026#34;\u0026#34;, DB: 0, }), // Add routes EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/products\u0026#34;, GetProducts), EpicServer.Get(\u0026#34;/products/:id\u0026#34;, GetProduct), EpicServer.Post(\u0026#34;/products\u0026#34;, CreateProduct), EpicServer.Put(\u0026#34;/products/:id\u0026#34;, UpdateProduct), EpicServer.Delete(\u0026#34;/products/:id\u0026#34;, DeleteProduct), }, }, ), }) // Start the server server.Start() } // GetProducts returns all products with caching func GetProducts(c *gin.Context, s *EpicServer.Server) { cacheKey := \u0026#34;products:all\u0026#34; // Try to get from cache first cache, _ := s.GetCache(\u0026#34;default\u0026#34;) var productsJSON string found, _ := cache.Get(cacheKey, \u0026amp;productsJSON) if found { // Return cached products c.Header(\u0026#34;X-Cache\u0026#34;, \u0026#34;HIT\u0026#34;) c.Data(200, \u0026#34;application/json\u0026#34;, []byte(productsJSON)) return } // Get from database if not in cache collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;products\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() cursor, err := collection.Find(ctx, bson.M{}) if err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Database error\u0026#34;}) return } defer cursor.Close(ctx) var products []Product if err := cursor.All(ctx, \u0026amp;products); err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to decode products\u0026#34;}) return } // Store in cache for future requests productsData, _ := json.Marshal(products) productsJSON = string(productsData) cache.Set(cacheKey, productsJSON, 5*time.Minute) // Return products c.Header(\u0026#34;X-Cache\u0026#34;, \u0026#34;MISS\u0026#34;) c.Data(200, \u0026#34;application/json\u0026#34;, productsData) } // GetProduct returns a single product with caching func GetProduct(c *gin.Context, s *EpicServer.Server) { productID := c.Param(\u0026#34;id\u0026#34;) cacheKey := \u0026#34;product:\u0026#34; + productID // Try to get from cache first cache, _ := s.GetCache(\u0026#34;default\u0026#34;) var productJSON string found, _ := cache.Get(cacheKey, \u0026amp;productJSON) if found { // Return cached product c.Header(\u0026#34;X-Cache\u0026#34;, \u0026#34;HIT\u0026#34;) c.Data(200, \u0026#34;application/json\u0026#34;, []byte(productJSON)) return } // Get from database if not in cache collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;products\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() objectID, err := primitive.ObjectIDFromHex(productID) if err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid product ID\u0026#34;}) return } var product Product err = collection.FindOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}).Decode(\u0026amp;product) if err != nil { c.JSON(404, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Product not found\u0026#34;}) return } // Store in cache for future requests productData, _ := json.Marshal(product) productJSON = string(productData) cache.Set(cacheKey, productJSON, 5*time.Minute) // Return product c.Header(\u0026#34;X-Cache\u0026#34;, \u0026#34;MISS\u0026#34;) c.Data(200, \u0026#34;application/json\u0026#34;, productData) } // CreateProduct creates a new product and invalidates cache func CreateProduct(c *gin.Context, s *EpicServer.Server) { var product Product if err := c.ShouldBindJSON(\u0026amp;product); err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Set timestamps now := time.Now() product.CreatedAt = now product.UpdatedAt = now // Insert into database collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;products\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() result, err := collection.InsertOne(ctx, product) if err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to create product\u0026#34;}) return } // Get the inserted ID product.ID = result.InsertedID.(primitive.ObjectID) // Invalidate cache cache, _ := s.GetCache(\u0026#34;default\u0026#34;) cache.Delete(\u0026#34;products:all\u0026#34;) c.JSON(201, product) } // UpdateProduct updates a product and invalidates cache func UpdateProduct(c *gin.Context, s *EpicServer.Server) { productID := c.Param(\u0026#34;id\u0026#34;) var updateData Product if err := c.ShouldBindJSON(\u0026amp;updateData); err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: err.Error()}) return } // Update in database collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;products\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() objectID, err := primitive.ObjectIDFromHex(productID) if err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid product ID\u0026#34;}) return } update := bson.M{ \u0026#34;$set\u0026#34;: bson.M{ \u0026#34;name\u0026#34;: updateData.Name, \u0026#34;description\u0026#34;: updateData.Description, \u0026#34;price\u0026#34;: updateData.Price, \u0026#34;updated_at\u0026#34;: time.Now(), }, } _, err = collection.UpdateOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}, update) if err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to update product\u0026#34;}) return } // Invalidate cache cache, _ := s.GetCache(\u0026#34;default\u0026#34;) cache.Delete(\u0026#34;products:all\u0026#34;) cache.Delete(\u0026#34;product:\u0026#34; + productID) c.JSON(200, gin.H{\u0026#34;message\u0026#34;: \u0026#34;Product updated successfully\u0026#34;}) } // DeleteProduct deletes a product and invalidates cache func DeleteProduct(c *gin.Context, s *EpicServer.Server) { productID := c.Param(\u0026#34;id\u0026#34;) // Delete from database collection, _ := EpicServerDb.GetMongoCollection(s, \u0026#34;default\u0026#34;, \u0026#34;myapp\u0026#34;, \u0026#34;products\u0026#34;) ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() objectID, err := primitive.ObjectIDFromHex(productID) if err != nil { c.JSON(400, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Invalid product ID\u0026#34;}) return } _, err = collection.DeleteOne(ctx, bson.M{\u0026#34;_id\u0026#34;: objectID}) if err != nil { c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to delete product\u0026#34;}) return } // Invalidate cache cache, _ := s.GetCache(\u0026#34;default\u0026#34;) cache.Delete(\u0026#34;products:all\u0026#34;) cache.Delete(\u0026#34;product:\u0026#34; + productID) c.JSON(200, gin.H{\u0026#34;message\u0026#34;: \u0026#34;Product deleted successfully\u0026#34;}) }\r","date":"2023-09-07","id":17,"permalink":"/docs/guides/caching/","summary":"A comprehensive guide to implementing caching in EpicServer.","tags":[],"title":"Caching"},{"content":"Community GitHub Repository: EpicServer on GitHub Issues: Report bugs or request features Discussions: Join the community discussions Additional Learning Go Documentation: official Go documentation Gin Framework: Gin Web Framework RESTful API Design: Best Practices for REST API Design Tools and Integrations Visual Studio Code Go Extension: Go extension for VS Code Postman: API Development Environment Docker: Container platform Example Projects Basic API Server: EpicServer Basic API Example Authentication Service: EpicServer Auth Example RESTful API: EpicServer RESTful Example Books and Articles Building Web Applications with Go: A comprehensive guide to building web applications using Go API Design Patterns: Best practices for designing REST APIs Microservices with Go: Learn how to build microservices with Go and EpicServer Videos and Tutorials Getting Started with EpicServer: A video tutorial series covering the basics Advanced EpicServer Patterns: Deep dive into advanced usage patterns Scaling EpicServer Applications: Best practices for scaling your application Official Resources GitHub Repository: EpicServer on GitHub Issues: Report bugs or request features Discussions: Join the community discussions Note: Version 2.x is the only supported version of EpicServer. Version 1.x is deprecated and will not receive updates or security patches. All users are strongly encouraged to migrate to v2.x as soon as possible.\n","date":"2023-09-07","id":18,"permalink":"/docs/resources/","summary":"Additional resources to help you get the most out of EpicServer.","tags":[],"title":"Resources"},{"content":"Logging in EpicServer EpicServer provides a powerful structured logging system that helps you track application events, errors, and performance metrics. This guide will show you how to configure and use the logging system effectively.\nBasic Logging The logging system is automatically initialized when you create a new server instance. You can access the logger through the server object:\npackage main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{}) // Access the logger logger := server.Logger // Log messages at different levels logger.Debug(\u0026#34;Debug message\u0026#34;) logger.Info(\u0026#34;Info message\u0026#34;) logger.Warn(\u0026#34;Warning message\u0026#34;) logger.Error(\u0026#34;Error message\u0026#34;) server.Start() }\rStructured Logging EpicServer v2.0.0+ supports structured logging, which allows you to include additional context with your log messages:\n// Log with structured fields logger.Info(\u0026#34;User logged in\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.1.1\u0026#34;, }) // Log errors with context err := someFunction() if err != nil { logger.Error(\u0026#34;Operation failed\u0026#34;, map[string]interface{}{ \u0026#34;operation\u0026#34;: \u0026#34;user_update\u0026#34;, \u0026#34;error\u0026#34;: err.Error(), }) }\rConfiguring Log Levels You can configure the log level when creating the server:\nserver := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;debug\u0026#34;, // Options: debug, info, warn, error }), }, })\rConfiguring Log Format EpicServer supports multiple log formats:\nserver := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithLogConfig(EpicServer.LogConfig{ Format: \u0026#34;json\u0026#34;, // Options: text, json }), }, })\rEnvironment Variables for Logging You can also configure logging using environment variables:\nLOG_LEVEL=debug LOG_FORMAT=json\rModule-Based Logging (v2.0.2+) EpicServer v2.0.2 introduced module-based logging, which allows you to organize logs by module and set different log levels for different parts of your application:\npackage main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;info\u0026#34;, Format: \u0026#34;json\u0026#34;, }), }, }) // Create module loggers authLogger := server.Logger.Module(\u0026#34;auth\u0026#34;) dbLogger := server.Logger.Module(\u0026#34;db\u0026#34;) apiLogger := server.Logger.Module(\u0026#34;api\u0026#34;) // Use module loggers authLogger.Info(\u0026#34;Auth system initialized\u0026#34;) dbLogger.Debug(\u0026#34;Database connection established\u0026#34;) apiLogger.Warn(\u0026#34;API rate limit reached\u0026#34;, map[string]interface{}{ \u0026#34;endpoint\u0026#34;: \u0026#34;/users\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;192.168.1.1\u0026#34;, }) server.Start() }\rHierarchical Module Logging Module loggers can be organized hierarchically:\n// Create parent module apiLogger := server.Logger.Module(\u0026#34;api\u0026#34;) // Create child modules usersLogger := apiLogger.Module(\u0026#34;users\u0026#34;) productsLogger := apiLogger.Module(\u0026#34;products\u0026#34;) // Log with child modules usersLogger.Info(\u0026#34;User created\u0026#34;, map[string]interface{}{\u0026#34;user_id\u0026#34;: \u0026#34;123\u0026#34;}) productsLogger.Debug(\u0026#34;Product fetched\u0026#34;, map[string]interface{}{\u0026#34;product_id\u0026#34;: \u0026#34;456\u0026#34;})\rSetting Log Levels for Modules You can set different log levels for different modules:\n// Set global log level server.Logger.SetLevel(\u0026#34;info\u0026#34;) // Set module-specific log levels authLogger := server.Logger.Module(\u0026#34;auth\u0026#34;) authLogger.SetLevel(\u0026#34;debug\u0026#34;) dbLogger := server.Logger.Module(\u0026#34;db\u0026#34;) dbLogger.SetLevel(\u0026#34;warn\u0026#34;)\rLog Level Inheritance Child modules inherit log levels from their parents unless explicitly overridden:\n// Set parent module level apiLogger := server.Logger.Module(\u0026#34;api\u0026#34;) apiLogger.SetLevel(\u0026#34;info\u0026#34;) // Child modules inherit parent level usersLogger := apiLogger.Module(\u0026#34;users\u0026#34;) productsLogger := apiLogger.Module(\u0026#34;products\u0026#34;) // Override level for specific child productsLogger.SetLevel(\u0026#34;debug\u0026#34;)\rCustom Log Registry For advanced use cases, you can create a custom log registry:\n// Create custom registry registry := EpicServer.NewLogRegistry() // Create root logger logger := registry.GetLogger() logger.SetLevel(\u0026#34;info\u0026#34;) // Create module loggers authLogger := registry.GetLogger(\u0026#34;auth\u0026#34;) dbLogger := registry.GetLogger(\u0026#34;db\u0026#34;) // Set module levels authLogger.SetLevel(\u0026#34;debug\u0026#34;) dbLogger.SetLevel(\u0026#34;warn\u0026#34;)\rLogging in Route Handlers You can access the logger in your route handlers:\nfunc UserHandler(c *gin.Context, s *EpicServer.Server) { // Get logger logger := s.Logger // Create module logger for this handler userLogger := logger.Module(\u0026#34;handlers.user\u0026#34;) userID := c.Param(\u0026#34;id\u0026#34;) userLogger.Info(\u0026#34;Fetching user\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: userID, \u0026#34;method\u0026#34;: c.Request.Method, \u0026#34;path\u0026#34;: c.Request.URL.Path, }) // Process request... userLogger.Debug(\u0026#34;User request completed\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: userID, \u0026#34;status_code\u0026#34;: 200, \u0026#34;duration_ms\u0026#34;: 42, }) }\rLogging Middleware EpicServer automatically logs HTTP requests using middleware. You can customize this behavior:\nserver := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;info\u0026#34;, Format: \u0026#34;json\u0026#34;, LogRequests: true, LogRequestBody: false, LogResponseBody: false, LogRequestHeader: false, }), }, })\rComplete Logging Example Here\u0026rsquo;s a complete example demonstrating various logging features:\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) // UserService handles user-related operations type UserService struct { logger EpicServer.Logger } // NewUserService creates a new user service func NewUserService(logger EpicServer.Logger) *UserService { return \u0026amp;UserService{ logger: logger.Module(\u0026#34;services.user\u0026#34;), } } // GetUser retrieves a user by ID func (s *UserService) GetUser(id string) (map[string]interface{}, error) { s.logger.Debug(\u0026#34;Getting user\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: id, }) // Simulate database operation time.Sleep(100 * time.Millisecond) // Return mock user user := map[string]interface{}{ \u0026#34;id\u0026#34;: id, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;john@example.com\u0026#34;, } s.logger.Info(\u0026#34;User retrieved\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: id, }) return user, nil } // GetUserHandler handles user GET requests func GetUserHandler(c *gin.Context, s *EpicServer.Server) { // Create handler logger logger := s.Logger.Module(\u0026#34;handlers.user\u0026#34;) // Create user service userService := NewUserService(s.Logger) // Get user ID from path userID := c.Param(\u0026#34;id\u0026#34;) // Log request logger.Info(\u0026#34;User request received\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: userID, \u0026#34;method\u0026#34;: c.Request.Method, \u0026#34;path\u0026#34;: c.Request.URL.Path, \u0026#34;client_ip\u0026#34;: c.ClientIP(), }) // Get user start := time.Now() user, err := userService.GetUser(userID) duration := time.Since(start) // Handle error if err != nil { logger.Error(\u0026#34;Failed to get user\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: userID, \u0026#34;error\u0026#34;: err.Error(), \u0026#34;duration_ms\u0026#34;: duration.Milliseconds(), }) c.JSON(500, gin.H{\u0026#34;error\u0026#34;: \u0026#34;Failed to get user\u0026#34;}) return } // Log success logger.Debug(\u0026#34;User request completed\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: userID, \u0026#34;status_code\u0026#34;: 200, \u0026#34;duration_ms\u0026#34;: duration.Milliseconds(), }) // Return user c.JSON(200, user) } func main() { // Initialize server server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Configure logging EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;debug\u0026#34;, Format: \u0026#34;json\u0026#34;, }), // Add routes EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/users/:id\u0026#34;, GetUserHandler), }, }, ), }, }) // Configure module loggers apiLogger := server.Logger.Module(\u0026#34;api\u0026#34;) apiLogger.SetLevel(\u0026#34;debug\u0026#34;) dbLogger := server.Logger.Module(\u0026#34;db\u0026#34;) dbLogger.SetLevel(\u0026#34;info\u0026#34;) authLogger := server.Logger.Module(\u0026#34;auth\u0026#34;) authLogger.SetLevel(\u0026#34;warn\u0026#34;) // Log server startup server.Logger.Info(\u0026#34;Server starting\u0026#34;, map[string]interface{}{ \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 8080, \u0026#34;env\u0026#34;: \u0026#34;development\u0026#34;, }) // Start the server server.Start() }\rBest Practices for Logging 1. Use Appropriate Log Levels Debug: Detailed information useful for debugging Info: General information about application operation Warn: Potential issues that don\u0026rsquo;t prevent operation Error: Errors that prevent normal operation 2. Include Contextual Information Always include relevant context with your log messages:\nlogger.Info(\u0026#34;User authentication\u0026#34;, map[string]interface{}{ \u0026#34;user_id\u0026#34;: userID, \u0026#34;ip\u0026#34;: clientIP, \u0026#34;success\u0026#34;: true, \u0026#34;auth_type\u0026#34;: \u0026#34;oauth\u0026#34;, })\r3. Use Module-Based Logging Organize your logs by module to make them easier to filter and analyze:\nauthLogger := server.Logger.Module(\u0026#34;auth\u0026#34;) dbLogger := server.Logger.Module(\u0026#34;db\u0026#34;) apiLogger := server.Logger.Module(\u0026#34;api\u0026#34;)\r4. Log Request/Response Information Log important information about HTTP requests and responses:\nlogger.Info(\u0026#34;API request\u0026#34;, map[string]interface{}{ \u0026#34;method\u0026#34;: c.Request.Method, \u0026#34;path\u0026#34;: c.Request.URL.Path, \u0026#34;client_ip\u0026#34;: c.ClientIP(), \u0026#34;status_code\u0026#34;: statusCode, \u0026#34;duration_ms\u0026#34;: duration.Milliseconds(), })\r5. Log Performance Metrics Include timing information for important operations:\nstart := time.Now() result, err := performOperation() duration := time.Since(start) logger.Info(\u0026#34;Operation completed\u0026#34;, map[string]interface{}{ \u0026#34;operation\u0026#34;: \u0026#34;data_processing\u0026#34;, \u0026#34;duration_ms\u0026#34;: duration.Milliseconds(), \u0026#34;records\u0026#34;: len(result), })\r6. Configure Production Logging In production, consider these settings:\nserver := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;info\u0026#34;, // Avoid debug in production Format: \u0026#34;json\u0026#34;, // JSON for log aggregation LogRequests: true, LogRequestBody: false, // Avoid logging sensitive data LogResponseBody: false, // Avoid excessive logging }), }, })\r","date":"2023-09-07","id":19,"permalink":"/docs/guides/logging/","summary":"A comprehensive guide to configuring and using the structured logging system in EpicServer.","tags":[],"title":"Logging"},{"content":"Configuration in EpicServer EpicServer provides a flexible configuration system that allows you to customize your server through code, environment variables, and configuration files. This guide will show you how to use these different configuration methods effectively.\nBasic Configuration The simplest way to configure EpicServer is through the server initialization parameters:\npackage main import ( \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; ) func main() { server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Configure host and port EpicServer.WithHost(\u0026#34;localhost\u0026#34;, 8080), // Configure secret key EpicServer.WithSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), }, }) server.Start() }\rServer Options EpicServer provides several options for configuring your server:\nserver := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Host and port EpicServer.WithHost(\u0026#34;localhost\u0026#34;, 8080), // Secret key for encryption EpicServer.WithSecretKey([]byte(\u0026#34;your-secret-key\u0026#34;)), // Trusted proxies EpicServer.WithTrustedProxies([]string{\u0026#34;192.168.1.1\u0026#34;, \u0026#34;10.0.0.1\u0026#34;}), // CORS configuration EpicServer.WithCORS(\u0026amp;EpicServer.CORSConfig{ AllowOrigins: []string{\u0026#34;https://example.com\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;}, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Authorization\u0026#34;}, ExposeHeaders: []string{\u0026#34;Content-Length\u0026#34;}, AllowCredentials: true, MaxAge: 12 * time.Hour, }), // Static file serving EpicServer.WithStaticFiles(\u0026#34;/static\u0026#34;, \u0026#34;./static\u0026#34;), // Public paths (no authentication required) EpicServer.WithPublicPaths(EpicServer.PublicPathConfig{ Exact: []string{\u0026#34;/health\u0026#34;, \u0026#34;/login\u0026#34;}, Prefix: []string{\u0026#34;/public\u0026#34;, \u0026#34;/api/v1/public\u0026#34;}, }), }, })\rEnvironment Variables EpicServer can be configured using environment variables:\n# Server configuration HOST=localhost PORT=8080 SECRET_KEY=your-secret-key TRUSTED_PROXIES=192.168.1.1,10.0.0.1 # Database configuration MONGO_URI=mongodb://localhost:27017 MONGO_DB=myapp POSTGRES_URI=postgres://user:password@localhost:5432/myapp MYSQL_URI=mysql://user:password@localhost:3306/myapp # Authentication configuration SECURE_COOKIE_HASH_KEY=base64_encoded_32_byte_key SECURE_COOKIE_BLOCK_KEY=base64_encoded_32_byte_key ENCRYPTION_KEY=32_byte_hex_encoded_key # Logging configuration LOG_LEVEL=debug LOG_FORMAT=json # Cache configuration REDIS_URI=redis://localhost:6379 MEMORY_CACHE_EXPIRATION=5m MEMORY_CACHE_CLEANUP_INTERVAL=10m\rLoading Environment Variables EpicServer automatically loads environment variables when you create a new server instance. You can also explicitly load them:\n// Load environment variables from .env file EpicServer.LoadEnv() // Create server (will use environment variables) server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{})\rConfiguration Files You can also use configuration files to configure EpicServer. Create a config.json file:\n{ \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 8080, \u0026#34;secretKey\u0026#34;: \u0026#34;your-secret-key\u0026#34;, \u0026#34;trustedProxies\u0026#34;: [\u0026#34;192.168.1.1\u0026#34;, \u0026#34;10.0.0.1\u0026#34;], \u0026#34;cors\u0026#34;: { \u0026#34;allowOrigins\u0026#34;: [\u0026#34;https://example.com\u0026#34;], \u0026#34;allowMethods\u0026#34;: [\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;], \u0026#34;allowHeaders\u0026#34;: [\u0026#34;Origin\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Authorization\u0026#34;], \u0026#34;exposeHeaders\u0026#34;: [\u0026#34;Content-Length\u0026#34;], \u0026#34;allowCredentials\u0026#34;: true, \u0026#34;maxAge\u0026#34;: 43200 }, \u0026#34;database\u0026#34;: { \u0026#34;mongo\u0026#34;: { \u0026#34;uri\u0026#34;: \u0026#34;mongodb://localhost:27017\u0026#34;, \u0026#34;database\u0026#34;: \u0026#34;myapp\u0026#34; }, \u0026#34;postgres\u0026#34;: { \u0026#34;uri\u0026#34;: \u0026#34;postgres://user:password@localhost:5432/myapp\u0026#34; } }, \u0026#34;auth\u0026#34;: { \u0026#34;providers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;google\u0026#34;, \u0026#34;clientId\u0026#34;: \u0026#34;your-client-id\u0026#34;, \u0026#34;clientSecret\u0026#34;: \u0026#34;your-client-secret\u0026#34;, \u0026#34;callback\u0026#34;: \u0026#34;http://localhost:8080/auth/google/callback\u0026#34; } ], \u0026#34;session\u0026#34;: { \u0026#34;cookieName\u0026#34;: \u0026#34;auth_session\u0026#34;, \u0026#34;cookieDomain\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;cookieSecure\u0026#34;: false, \u0026#34;cookieHTTPOnly\u0026#34;: true, \u0026#34;sessionDuration\u0026#34;: 86400 } }, \u0026#34;logging\u0026#34;: { \u0026#34;level\u0026#34;: \u0026#34;debug\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;json\u0026#34; }, \u0026#34;cache\u0026#34;: { \u0026#34;redis\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;localhost:6379\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;db\u0026#34;: 0 }, \u0026#34;memory\u0026#34;: { \u0026#34;defaultExpiration\u0026#34;: 300, \u0026#34;cleanupInterval\u0026#34;: 600 } } }\rThen load the configuration file:\n// Load configuration from file config, err := EpicServer.LoadConfig(\u0026#34;config.json\u0026#34;) if err != nil { panic(err) } // Create server with loaded configuration server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ Config: config, })\rConfiguration Priority EpicServer uses the following priority order when resolving configuration:\nExplicit configuration in code Configuration files Environment variables Default values This means that values specified in code will override values from configuration files, which will override environment variables.\nDynamic Configuration You can update the server configuration after initialization:\n// Create server server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{}) // Update configuration server.UpdateAppLayer([]EpicServer.AppLayer{ EpicServer.WithHost(\u0026#34;0.0.0.0\u0026#34;, 3000), EpicServer.WithCORS(\u0026amp;EpicServer.CORSConfig{ AllowOrigins: []string{\u0026#34;https://example.com\u0026#34;}, }), })\rConfiguration Validation EpicServer validates your configuration when you create a new server instance. If there are any issues with your configuration, the server will return an error:\nserver, err := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ // Configuration... }) if err != nil { // Handle configuration error panic(err) }\rCommon Configuration Scenarios Configuring for Development server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Development host and port EpicServer.WithHost(\u0026#34;localhost\u0026#34;, 8080), // Development database EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapp_dev\u0026#34;, }), // Development logging EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;debug\u0026#34;, Format: \u0026#34;text\u0026#34;, }), // In-memory cache for development EpicServer.WithMemoryCache(\u0026amp;EpicServer.MemoryCacheConfig{ DefaultExpiration: 5 * time.Minute, CleanupInterval: 10 * time.Minute, ConnectionName: \u0026#34;default\u0026#34;, }), // CORS for development EpicServer.WithCORS(\u0026amp;EpicServer.CORSConfig{ AllowOrigins: []string{\u0026#34;http://localhost:3000\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;}, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Authorization\u0026#34;}, AllowCredentials: true, }), }, })\rConfiguring for Production server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Production host and port EpicServer.WithHost(\u0026#34;0.0.0.0\u0026#34;, 8080), // Production database EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: os.Getenv(\u0026#34;MONGO_URI\u0026#34;), DatabaseName: \u0026#34;myapp_prod\u0026#34;, }), // Production logging EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;info\u0026#34;, Format: \u0026#34;json\u0026#34;, }), // Redis cache for production EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;default\u0026#34;, Address: os.Getenv(\u0026#34;REDIS_URI\u0026#34;), Password: os.Getenv(\u0026#34;REDIS_PASSWORD\u0026#34;), DB: 0, }), // CORS for production EpicServer.WithCORS(\u0026amp;EpicServer.CORSConfig{ AllowOrigins: []string{\u0026#34;https://example.com\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;}, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Authorization\u0026#34;}, AllowCredentials: true, MaxAge: 12 * time.Hour, }), // Rate limiting for production EpicServer.WithRateLimiter(EpicServer.RateLimiterConfig{ MaxRequests: 100, Interval: time.Minute, BlockDuration: 5 * time.Minute, }), }, })\rEnvironment-Based Configuration package main import ( \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { // Load environment variables EpicServer.LoadEnv() // Determine environment env := os.Getenv(\u0026#34;APP_ENV\u0026#34;) if env == \u0026#34;\u0026#34; { env = \u0026#34;development\u0026#34; } // Create base configuration appLayers := []EpicServer.AppLayer{ // Common configuration EpicServer.WithHost(os.Getenv(\u0026#34;HOST\u0026#34;), 8080), EpicServer.WithSecretKey([]byte(os.Getenv(\u0026#34;SECRET_KEY\u0026#34;))), } // Add environment-specific configuration switch env { case \u0026#34;production\u0026#34;: // Production configuration appLayers = append(appLayers, EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: os.Getenv(\u0026#34;MONGO_URI\u0026#34;), DatabaseName: \u0026#34;myapp_prod\u0026#34;, }), EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;info\u0026#34;, Format: \u0026#34;json\u0026#34;, }), EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;default\u0026#34;, Address: os.Getenv(\u0026#34;REDIS_URI\u0026#34;), Password: os.Getenv(\u0026#34;REDIS_PASSWORD\u0026#34;), DB: 0, }), EpicServer.WithRateLimiter(EpicServer.RateLimiterConfig{ MaxRequests: 100, Interval: time.Minute, BlockDuration: 5 * time.Minute, }), ) case \u0026#34;staging\u0026#34;: // Staging configuration appLayers = append(appLayers, EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: os.Getenv(\u0026#34;MONGO_URI\u0026#34;), DatabaseName: \u0026#34;myapp_staging\u0026#34;, }), EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;debug\u0026#34;, Format: \u0026#34;json\u0026#34;, }), EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;default\u0026#34;, Address: os.Getenv(\u0026#34;REDIS_URI\u0026#34;), Password: os.Getenv(\u0026#34;REDIS_PASSWORD\u0026#34;), DB: 1, }), ) default: // Development configuration appLayers = append(appLayers, EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: \u0026#34;mongodb://localhost:27017\u0026#34;, DatabaseName: \u0026#34;myapp_dev\u0026#34;, }), EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: \u0026#34;debug\u0026#34;, Format: \u0026#34;text\u0026#34;, }), EpicServer.WithMemoryCache(\u0026amp;EpicServer.MemoryCacheConfig{ DefaultExpiration: 5 * time.Minute, CleanupInterval: 10 * time.Minute, ConnectionName: \u0026#34;default\u0026#34;, }), ) } // Create server with environment-specific configuration server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: appLayers, }) // Start server server.Start() }\rComplete Configuration Example Here\u0026rsquo;s a complete example demonstrating various configuration options:\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/v2\u0026#34; \u0026#34;github.com/tomskip123/EpicServer/db\u0026#34; ) func main() { // Load environment variables EpicServer.LoadEnv() // Create server server := EpicServer.NewServer(\u0026amp;EpicServer.NewServerParam{ AppLayer: []EpicServer.AppLayer{ // Server configuration EpicServer.WithHost(os.Getenv(\u0026#34;HOST\u0026#34;), 8080), EpicServer.WithSecretKey([]byte(os.Getenv(\u0026#34;SECRET_KEY\u0026#34;))), EpicServer.WithTrustedProxies([]string{\u0026#34;192.168.1.1\u0026#34;, \u0026#34;10.0.0.1\u0026#34;}), // Database configuration EpicServerDb.WithMongo(\u0026amp;EpicServerDb.MongoConfig{ ConnectionName: \u0026#34;default\u0026#34;, URI: os.Getenv(\u0026#34;MONGO_URI\u0026#34;), DatabaseName: os.Getenv(\u0026#34;MONGO_DB\u0026#34;), }), EpicServerDb.WithPostgres(\u0026amp;EpicServerDb.PostgresConfig{ ConnectionName: \u0026#34;postgres\u0026#34;, URI: os.Getenv(\u0026#34;POSTGRES_URI\u0026#34;), }), // Cache configuration EpicServer.WithRedisCache(\u0026amp;EpicServer.RedisCacheConfig{ ConnectionName: \u0026#34;default\u0026#34;, Address: os.Getenv(\u0026#34;REDIS_URI\u0026#34;), Password: os.Getenv(\u0026#34;REDIS_PASSWORD\u0026#34;), DB: 0, }), EpicServer.WithMemoryCache(\u0026amp;EpicServer.MemoryCacheConfig{ ConnectionName: \u0026#34;local\u0026#34;, DefaultExpiration: 5 * time.Minute, CleanupInterval: 10 * time.Minute, }), // Authentication configuration EpicServer.WithAuth([]EpicServer.Provider{ { Name: \u0026#34;google\u0026#34;, ClientId: os.Getenv(\u0026#34;GOOGLE_CLIENT_ID\u0026#34;), ClientSecret: os.Getenv(\u0026#34;GOOGLE_CLIENT_SECRET\u0026#34;), Callback: os.Getenv(\u0026#34;GOOGLE_CALLBACK_URL\u0026#34;), }, }, \u0026amp;EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: os.Getenv(\u0026#34;COOKIE_DOMAIN\u0026#34;), CookieSecure: os.Getenv(\u0026#34;APP_ENV\u0026#34;) == \u0026#34;production\u0026#34;, CookieHTTPOnly: true, SessionDuration: 24 * time.Hour, }), EpicServer.WithAuthMiddleware(EpicServer.SessionConfig{ CookieName: \u0026#34;auth_session\u0026#34;, CookieDomain: os.Getenv(\u0026#34;COOKIE_DOMAIN\u0026#34;), CookieSecure: os.Getenv(\u0026#34;APP_ENV\u0026#34;) == \u0026#34;production\u0026#34;, }), // Public paths EpicServer.WithPublicPaths(EpicServer.PublicPathConfig{ Exact: []string{ \u0026#34;/health\u0026#34;, \u0026#34;/login\u0026#34;, }, Prefix: []string{ \u0026#34;/auth\u0026#34;, \u0026#34;/public\u0026#34;, \u0026#34;/api/v1/public\u0026#34;, }, }), // CORS configuration EpicServer.WithCORS(\u0026amp;EpicServer.CORSConfig{ AllowOrigins: []string{os.Getenv(\u0026#34;CORS_ALLOW_ORIGIN\u0026#34;)}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;, \u0026#34;OPTIONS\u0026#34;}, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Authorization\u0026#34;}, ExposeHeaders: []string{\u0026#34;Content-Length\u0026#34;}, AllowCredentials: true, MaxAge: 12 * time.Hour, }), // Logging configuration EpicServer.WithLogConfig(EpicServer.LogConfig{ Level: os.Getenv(\u0026#34;LOG_LEVEL\u0026#34;), Format: os.Getenv(\u0026#34;LOG_FORMAT\u0026#34;), LogRequests: true, LogRequestBody: false, LogResponseBody: false, }), // Static files EpicServer.WithStaticFiles(\u0026#34;/static\u0026#34;, \u0026#34;./static\u0026#34;), // Security features EpicServer.WithCSRFProtection(), EpicServer.WithRateLimiter(EpicServer.RateLimiterConfig{ MaxRequests: 100, Interval: time.Minute, BlockDuration: 5 * time.Minute, ExcludedPaths: []string{\u0026#34;/health\u0026#34;, \u0026#34;/static/*\u0026#34;}, }), // Routes EpicServer.WithRoutes( EpicServer.RouteGroup{ Prefix: \u0026#34;/api/v1\u0026#34;, Routes: []EpicServer.Route{ EpicServer.Get(\u0026#34;/users\u0026#34;, GetUsers), EpicServer.Get(\u0026#34;/users/:id\u0026#34;, GetUser), EpicServer.Post(\u0026#34;/users\u0026#34;, CreateUser), EpicServer.Put(\u0026#34;/users/:id\u0026#34;, UpdateUser), EpicServer.Delete(\u0026#34;/users/:id\u0026#34;, DeleteUser), }, }, ), }, }) // Start server server.Start() } // Handler functions func GetUsers(c *gin.Context, s *EpicServer.Server) { // Implementation... } func GetUser(c *gin.Context, s *EpicServer.Server) { // Implementation... } func CreateUser(c *gin.Context, s *EpicServer.Server) { // Implementation... } func UpdateUser(c *gin.Context, s *EpicServer.Server) { // Implementation... } func DeleteUser(c *gin.Context, s *EpicServer.Server) { // Implementation... }\r","date":"2023-09-07","id":20,"permalink":"/docs/guides/configuration/","summary":"A comprehensive guide to configuring EpicServer using different methods.","tags":[],"title":"Configuration"},{"content":"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.\nFurther reading Read about how-to guides in the Diátaxis framework ","date":"2023-09-07","id":21,"permalink":"/docs/guides/example-guide/","summary":"\u003cp\u003eGuides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.\u003c/p\u003e","tags":[],"title":"Example Guide"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":22,"permalink":"/docs/reference/example-reference/","summary":"\u003cp\u003eReference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\u003c/p\u003e","tags":[],"title":"Example Reference"},{"content":"EpicServer A powerful, flexible, and production-ready Go web server built on top of Gin framework.\nGo Version: \u0026gt;=1.16 | Current Version: 2.0.3 | Coverage Status\n📥 Installation go get github.com/tomskip123/EpicServer/v2\rNote: Version 2.x is the only supported version. Version 1.x is deprecated and should not be used for new projects.\n⚠️ Breaking Changes in v2.0.0 Version 2.0.0 introduces significant improvements with breaking changes. See CHANGELOG.md for details and migration guide.\nKey changes:\nStructured logging replaces variadic logging Database connections now return errors instead of panicking Enhanced configuration system with validation Improved security features 📝 Enhanced Documentation in v2.0.1 Version 2.0.1 improves documentation with:\nDetailed migration guide with code examples Comprehensive API usage examples Improved integration examples with imports and context Enhanced changelog maintenance 🧪 Enhanced Test Coverage in v2.0.3 Version 2.0.3 improves test coverage and reliability:\nImproved overall test coverage to 80.7%, surpassing the minimum threshold of 80% Added comprehensive tests for CSRF protection functionality Enhanced logging test suite with additional test cases Fixed edge cases in authentication tests Added specific tests for middleware components 🔧 Recent Improvements in Unreleased Version Thread Safety Improvements: Fixed data race condition in Server struct by adding a mutex to protect concurrent access Updated Start() and Stop() methods to use mutex protection when accessing the HTTP server Enhanced tests to properly handle concurrent access to server resources Welcome to the official documentation for EpicServer, a powerful, flexible, and production-ready Go web server built on top of the Gin framework. This documentation will help you get started with EpicServer and provide detailed information on its features and capabilities.\n","date":"2023-09-07","id":23,"permalink":"/docs/","summary":"Complete documentation for the EpicServer Go web framework.","tags":[],"title":"EpicServer Documentation"},{"content":"","date":"2023-09-07","id":24,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"Get Started EpicServer provides a robust foundation for building web applications and APIs in Go. With features like structured logging, middleware support, and database integration, EpicServer helps you build production-ready applications quickly and confidently.\nQuick Links Installation Quick Start Guide API Reference Examples ","date":"2023-09-07","id":25,"permalink":"/","summary":"\u003ch2 id=\"get-started\"\u003eGet Started\u003c/h2\u003e\n\u003cp\u003eEpicServer provides a robust foundation for building web applications and APIs in Go. With features like structured logging, middleware support, and database integration, EpicServer helps you build production-ready applications quickly and confidently.\u003c/p\u003e","tags":[],"title":"EpicServer"},{"content":"","date":"0001-01-01","id":26,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":27,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":28,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]