[{"content":"The Getting Started section will guide you through installing and setting up EpicServer for your web application projects. Follow these guides to quickly get up and running with EpicServer\u0026rsquo;s powerful features.\n","date":"2023-09-07","id":0,"permalink":"/docs/getting-started/","summary":"Learn how to install and set up EpicServer for your web application.","tags":[],"title":"Getting Started"},{"content":"Prerequisites Before installing EpicServer, ensure you have:\nGo 1.16 or later installed A Go project initialized with Go modules Installation Add EpicServer to your project using Go modules:\ngo get -u github.com/tomskip123/EpicServer\rThis will install the latest version of EpicServer in your project.\nVerify Installation Verify the installation by checking your go.mod file. You should see EpicServer listed among your dependencies:\nrequire ( github.com/tomskip123/EpicServer v2.0.3 // other dependencies )\rNext Steps After installation, you can:\nFollow the Quick Start Guide to set up a basic server Learn about Core Concepts to understand EpicServer\u0026rsquo;s architecture Explore Examples to see EpicServer in action ","date":"2023-09-07","id":1,"permalink":"/docs/getting-started/installation/","summary":"Learn how to add EpicServer to your Go project using Go modules.","tags":[],"title":"Installation"},{"content":"Server NewServer func NewServer(config *Config) *Server\rCreates a new EpicServer instance with the provided configuration.\nParameters:\nconfig - The server configuration. If nil, default configuration is used. Returns:\nA new Server instance. Example:\nserver := epicserver.NewServer(\u0026amp;epicserver.Config{ Port: 8080, ReadTimeout: 30, // seconds WriteTimeout: 30, // seconds })\rServer.Start func (s *Server) Start() error\rStarts the HTTP server.\nReturns:\nAn error if the server fails to start. Example:\nif err := server.Start(); err != nil { log.Fatalf(\u0026#34;Server failed to start: %v\u0026#34;, err) }\rServer.Stop func (s *Server) Stop() error\rGracefully stops the HTTP server.\nReturns:\nAn error if the server fails to stop gracefully. Example:\nif err := server.Stop(); err != nil { log.Printf(\u0026#34;Error stopping server: %v\u0026#34;, err) }\rServer.GET, POST, PUT, DELETE, etc. func (s *Server) GET(path string, handlers ...HandlerFunc) IRoute func (s *Server) POST(path string, handlers ...HandlerFunc) IRoute func (s *Server) PUT(path string, handlers ...HandlerFunc) IRoute func (s *Server) DELETE(path string, handlers ...HandlerFunc) IRoute func (s *Server) PATCH(path string, handlers ...HandlerFunc) IRoute func (s *Server) HEAD(path string, handlers ...HandlerFunc) IRoute func (s *Server) OPTIONS(path string, handlers ...HandlerFunc) IRoute\rRegisters a route with the given HTTP method, path, and handlers.\nParameters:\npath - The URL path for the route. handlers - One or more handler functions for the route. Returns:\nAn IRoute instance that can be used for chaining. Example:\nserver.GET(\u0026#34;/users\u0026#34;, GetUsers) server.POST(\u0026#34;/users\u0026#34;, CreateUser)\rContext Context.Param func (c *Context) Param(key string) string\rGets the value of a URL parameter.\nParameters:\nkey - The name of the parameter. Returns:\nThe parameter value as a string. Example:\nfunc GetUser(ctx *epicserver.Context) { id := ctx.Param(\u0026#34;id\u0026#34;) // ... }\rContext.Query func (c *Context) Query(key string) string\rGets the value of a query parameter.\nParameters:\nkey - The name of the parameter. Returns:\nThe parameter value as a string. Example:\nfunc SearchUsers(ctx *epicserver.Context) { query := ctx.Query(\u0026#34;q\u0026#34;) // ... }\rContext.DefaultQuery func (c *Context) DefaultQuery(key, defaultValue string) string\rGets the value of a query parameter, or a default value if the parameter is not present.\nParameters:\nkey - The name of the parameter. defaultValue - The default value to return if the parameter is not present. Returns:\nThe parameter value as a string, or the default value. Example:\nfunc GetUsers(ctx *epicserver.Context) { page := ctx.DefaultQuery(\u0026#34;page\u0026#34;, \u0026#34;1\u0026#34;) // ... }\rContext.Bind func (c *Context) Bind(obj any) error\rBinds the request body to the given struct.\nParameters:\nobj - The struct to bind to. Returns:\nAn error if binding fails. Example:\nfunc CreateUser(ctx *epicserver.Context) { var user User if err := ctx.Bind(\u0026amp;user); err != nil { ctx.AbortWithError(http.StatusBadRequest, err) return } // ... }\rContext.JSON func (c *Context) JSON(code int, obj any)\rSends a JSON response.\nParameters:\ncode - The HTTP status code. obj - The object to be serialized to JSON. Example:\nfunc GetUser(ctx *epicserver.Context) { user := GetUserByID(ctx.Param(\u0026#34;id\u0026#34;)) ctx.JSON(http.StatusOK, user) }\rLogger NewLogger func NewLogger(config *LoggerConfig) *Logger\rCreates a new structured logger.\nParameters:\nconfig - The logger configuration. Returns:\nA new Logger instance. Example:\nlogger := epicserver.NewLogger(\u0026amp;epicserver.LoggerConfig{ Level: epicserver.LogLevelInfo, Format: epicserver.LogFormatJSON, })\rLogger.Info, Error, Debug, etc. func (l *Logger) Info(msg string, fields ...Field) func (l *Logger) Error(msg string, fields ...Field) func (l *Logger) Debug(msg string, fields ...Field) func (l *Logger) Warn(msg string, fields ...Field)\rLogs a message at the specified level with optional fields.\nParameters:\nmsg - The log message. fields - Optional fields to include in the log entry. Example:\nlogger.Info(\u0026#34;User created\u0026#34;, epicserver.String(\u0026#34;user_id\u0026#34;, \u0026#34;123\u0026#34;), epicserver.Int(\u0026#34;status\u0026#34;, 201), )\rConfiguration Config type Config struct { Port int ReadTimeout int WriteTimeout int IdleTimeout int MaxHeaderBytes int // other fields... }\rConfiguration for the EpicServer.\nFields:\nPort - The port to listen on. ReadTimeout - The maximum duration for reading the entire request, including the body. WriteTimeout - The maximum duration before timing out writes of the response. IdleTimeout - The maximum amount of time to wait for the next request when keep-alives are enabled. MaxHeaderBytes - The maximum number of bytes the server will read parsing the request header. ","date":"2023-09-07","id":2,"permalink":"/docs/reference/api-reference/","summary":"Detailed documentation of all EpicServer\u0026rsquo;s public API methods and types.","tags":[],"title":"API Reference"},{"content":"Introduction In this example, we\u0026rsquo;ll build a simple RESTful API for managing tasks. Our API will support the following operations:\nGet all tasks Get a task by ID Create a new task Update a task Delete a task Project Setup First, create a new directory for your project and initialize a Go module:\nmkdir task-api cd task-api go mod init task-api\rInstall EpicServer:\ngo get -u github.com/tomskip123/EpicServer\rDefine the Task Model Create a file named models.go with the following content:\npackage main import \u0026#34;time\u0026#34; type Task struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` Completed bool `json:\u0026#34;completed\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` UpdatedAt time.Time `json:\u0026#34;updated_at\u0026#34;` } // In-memory store for tasks var tasks = make(map[string]*Task)\rCreate API Handlers Create a file named handlers.go with the following content:\npackage main import ( \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/google/uuid\u0026#34; \u0026#34;github.com/tomskip123/EpicServer\u0026#34; ) // GetTasks returns all tasks func GetTasks(ctx *epicserver.Context) { // Convert map to slice for JSON response taskList := make([]*Task, 0, len(tasks)) for _, task := range tasks { taskList = append(taskList, task) } ctx.JSON(http.StatusOK, taskList) } // GetTask returns a task by ID func GetTask(ctx *epicserver.Context) { id := ctx.Param(\u0026#34;id\u0026#34;) task, exists := tasks[id] if !exists { ctx.JSON(http.StatusNotFound, epicserver.H{ \u0026#34;error\u0026#34;: \u0026#34;Task not found\u0026#34;, }) return } ctx.JSON(http.StatusOK, task) } // CreateTask creates a new task func CreateTask(ctx *epicserver.Context) { var taskInput struct { Title string `json:\u0026#34;title\u0026#34; binding:\u0026#34;required\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } if err := ctx.Bind(\u0026amp;taskInput); err != nil { ctx.JSON(http.StatusBadRequest, epicserver.H{ \u0026#34;error\u0026#34;: \u0026#34;Invalid input\u0026#34;, }) return } now := time.Now() task := \u0026amp;Task{ ID: uuid.New().String(), Title: taskInput.Title, Description: taskInput.Description, Completed: false, CreatedAt: now, UpdatedAt: now, } tasks[task.ID] = task ctx.JSON(http.StatusCreated, task) } // UpdateTask updates an existing task func UpdateTask(ctx *epicserver.Context) { id := ctx.Param(\u0026#34;id\u0026#34;) task, exists := tasks[id] if !exists { ctx.JSON(http.StatusNotFound, epicserver.H{ \u0026#34;error\u0026#34;: \u0026#34;Task not found\u0026#34;, }) return } var taskInput struct { Title string `json:\u0026#34;title\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` Completed bool `json:\u0026#34;completed\u0026#34;` } if err := ctx.Bind(\u0026amp;taskInput); err != nil { ctx.JSON(http.StatusBadRequest, epicserver.H{ \u0026#34;error\u0026#34;: \u0026#34;Invalid input\u0026#34;, }) return } // Update fields if provided if taskInput.Title != \u0026#34;\u0026#34; { task.Title = taskInput.Title } if taskInput.Description != \u0026#34;\u0026#34; { task.Description = taskInput.Description } task.Completed = taskInput.Completed task.UpdatedAt = time.Now() ctx.JSON(http.StatusOK, task) } // DeleteTask deletes a task func DeleteTask(ctx *epicserver.Context) { id := ctx.Param(\u0026#34;id\u0026#34;) _, exists := tasks[id] if !exists { ctx.JSON(http.StatusNotFound, epicserver.H{ \u0026#34;error\u0026#34;: \u0026#34;Task not found\u0026#34;, }) return } delete(tasks, id) ctx.JSON(http.StatusNoContent, nil) }\rCreate Main Application Create a file named main.go with the following content:\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/tomskip123/EpicServer\u0026#34; ) func main() { // Create a new server with default configuration server := epicserver.NewServer(\u0026amp;epicserver.Config{ Port: 8080, ReadTimeout: 30, WriteTimeout: 30, }) // Add middleware server.Use(epicserver.Logger()) server.Use(epicserver.Recovery()) // Define API routes api := server.Group(\u0026#34;/api\u0026#34;) { tasks := api.Group(\u0026#34;/tasks\u0026#34;) { tasks.GET(\u0026#34;\u0026#34;, GetTasks) tasks.GET(\u0026#34;/:id\u0026#34;, GetTask) tasks.POST(\u0026#34;\u0026#34;, CreateTask) tasks.PUT(\u0026#34;/:id\u0026#34;, UpdateTask) tasks.DELETE(\u0026#34;/:id\u0026#34;, DeleteTask) } } // Start the server log.Println(\u0026#34;API server starting on :8080...\u0026#34;) if err := server.Start(); err != nil { log.Fatalf(\u0026#34;Failed to start server: %v\u0026#34;, err) } }\rRun the API Server Run the server with:\ngo run .\rTest the API You can test the API using curl or any API client like Postman:\nCreate a Task curl -X POST http://localhost:8080/api/tasks \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;title\u0026#34;:\u0026#34;Learn EpicServer\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Build a simple REST API with EpicServer\u0026#34;}\u0026#39;\rGet All Tasks curl http://localhost:8080/api/tasks\rGet a Task by ID curl http://localhost:8080/api/tasks/{task_id}\rUpdate a Task curl -X PUT http://localhost:8080/api/tasks/{task_id} \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;completed\u0026#34;:true}\u0026#39;\rDelete a Task curl -X DELETE http://localhost:8080/api/tasks/{task_id}\rConclusion You\u0026rsquo;ve built a basic RESTful API using EpicServer! This example demonstrates how to:\nSet up a server with EpicServer Define and organize routes Create handlers for CRUD operations Use middleware for logging and recovery Work with JSON requests and responses This is just a starting point. You can extend this example by adding:\nDatabase integration (e.g., PostgreSQL, MongoDB) Authentication and authorization Input validation Error handling middleware Swagger documentation ","date":"2023-09-07","id":3,"permalink":"/docs/examples/basic-api-server/","summary":"Step-by-step guide to create a simple RESTful API using EpicServer.","tags":[],"title":"Basic API Server"},{"content":"Introduction to Routing Routing is a fundamental concept in web server development. In EpicServer, routing refers to how HTTP requests are directed to the appropriate handler functions based on the request URL and HTTP method.\nBasic Routing EpicServer provides methods for all standard HTTP methods:\nserver.GET(\u0026#34;/users\u0026#34;, GetUsers) server.POST(\u0026#34;/users\u0026#34;, CreateUser) server.PUT(\u0026#34;/users/:id\u0026#34;, UpdateUser) server.DELETE(\u0026#34;/users/:id\u0026#34;, DeleteUser) server.PATCH(\u0026#34;/users/:id\u0026#34;, PartialUpdateUser) server.HEAD(\u0026#34;/status\u0026#34;, CheckStatus) server.OPTIONS(\u0026#34;/users\u0026#34;, GetUserOptions)\rRoute Parameters You can define route parameters using the :param syntax:\nserver.GET(\u0026#34;/users/:id\u0026#34;, func(ctx *epicserver.Context) { id := ctx.Param(\u0026#34;id\u0026#34;) // Use the id parameter ctx.String(http.StatusOK, \u0026#34;User ID: %s\u0026#34;, id) })\rRoute Groups Route groups allow you to organize routes and apply middleware to specific groups:\n// Create an API group api := server.Group(\u0026#34;/api\u0026#34;) // Apply middleware to all routes in this group api.Use(AuthMiddleware()) // Define routes within the group api.GET(\u0026#34;/users\u0026#34;, GetUsers) api.POST(\u0026#34;/users\u0026#34;, CreateUser) // Create a nested group v1 := api.Group(\u0026#34;/v1\u0026#34;) v1.GET(\u0026#34;/products\u0026#34;, GetProductsV1)\rQuery Parameters You can access query parameters using the Query method:\nserver.GET(\u0026#34;/search\u0026#34;, func(ctx *epicserver.Context) { query := ctx.Query(\u0026#34;q\u0026#34;) page := ctx.DefaultQuery(\u0026#34;page\u0026#34;, \u0026#34;1\u0026#34;) // Use the query parameters ctx.JSON(http.StatusOK, gin.H{ \u0026#34;query\u0026#34;: query, \u0026#34;page\u0026#34;: page, }) })\rWildcard Routes EpicServer supports wildcard routes for matching multiple path segments:\nserver.GET(\u0026#34;/static/*filepath\u0026#34;, func(ctx *epicserver.Context) { filepath := ctx.Param(\u0026#34;filepath\u0026#34;) // Serve static file from filepath })\rCustom HTTP Methods You can handle custom HTTP methods using the Handle method:\nserver.Handle(\u0026#34;PROPFIND\u0026#34;, \u0026#34;/resources\u0026#34;, HandlePropFind)\rBest Practices Organize Routes: Use route groups to keep your code organized and apply middleware consistently. Descriptive Names: Use descriptive route paths that reflect your resource hierarchy. Versioning: Consider versioning your API routes (e.g., /api/v1/users). RESTful Design: Follow RESTful principles when designing your API endpoints. Error Handling: Implement consistent error handling across your routes. ","date":"2023-09-07","id":4,"permalink":"/docs/guides/routing/","summary":"Complete guide to defining and managing HTTP routes in EpicServer.","tags":[],"title":"Routing"},{"content":"Overview EpicServer is built on top of the Gin framework, providing a powerful and flexible foundation for web applications and APIs. The architecture of EpicServer is designed to be modular, extensible, and easy to understand.\nHigh-Level Architecture At a high level, EpicServer\u0026rsquo;s architecture consists of the following components:\nServer Core: Manages the HTTP server and its lifecycle Router: Manages route registration and dispatching Middleware: Processes requests before they reach handlers Context: Encapsulates request and response Logger: Provides structured logging Configuration: Manages server configuration These components work together to provide a robust foundation for web applications.\n┌─────────────────────────────────────────────────────┐ │ EpicServer │ │ │ │ ┌─────────┐ ┌─────────┐ ┌─────────────────┐ │ │ │ Router │ │ Context │ │ Middleware Chain│ │ │ └─────────┘ └─────────┘ └─────────────────┘ │ │ │ │ │ │ │ └─────────────┼────────────────┘ │ │ │ │ │ ▼ │ │ ┌─────────┐ ┌─────────┐ ┌─────────────────┐ │ │ │ Logger │ │ Server │ │ Configuration │ │ │ └─────────┘ └─────────┘ └─────────────────┘ │ │ │ └─────────────────────────────────────────────────────┘ │ │ ▼ ▼ ┌─────────────────┐ ┌─────────────────┐ │ HTTP Client │ │ Database │ └─────────────────┘ └─────────────────┘\rServer Core The Server Core is responsible for initializing and managing the HTTP server. It handles:\nServer lifecycle (start, stop, graceful shutdown) Configuration application Middleware registration Route registration The Server Core is thread-safe, using mutexes to protect concurrent access to shared resources.\nRouter The Router component is responsible for:\nRegistering routes with HTTP methods (GET, POST, PUT, etc.) Creating route groups Parsing URL parameters Dispatching requests to the appropriate handler EpicServer\u0026rsquo;s router is built on top of Gin\u0026rsquo;s router, which uses a radix tree for efficient route matching.\nMiddleware Middleware functions process requests before they reach the handler, or after the response is generated. They form a chain, where each middleware can:\nModify the request Short-circuit the request processing Pass control to the next middleware Modify the response Common middleware provided by EpicServer include:\nLogging Recovery from panics CORS support Authentication Rate limiting Context The Context encapsulates the HTTP request and response, providing methods to:\nAccess request data (parameters, body, headers) Set and get values in the request context Send responses (JSON, HTML, XML, etc.) Handle errors The Context is passed to all middleware and handlers, providing a consistent interface for request processing.\nLogger EpicServer provides a structured logger that:\nSupports multiple log levels (DEBUG, INFO, WARN, ERROR) Outputs logs in various formats (text, JSON) Allows attaching structured fields to log entries Can be configured for different environments Configuration The Configuration component manages server settings, including:\nServer address and port Timeouts (read, write, idle) TLS settings Logger configuration Middleware configuration Request Lifecycle Client Request: A client sends an HTTP request to the server Server Receives Request: The HTTP server accepts the connection and passes the request to the router Middleware Processing: The request passes through the middleware chain Route Matching: The router matches the request to a registered route Handler Execution: The matched handler is executed Response Generation: The handler generates a response Middleware Post-Processing: The response passes back through the middleware chain Server Sends Response: The HTTP server sends the response back to the client Extending EpicServer EpicServer is designed to be extensible through:\nCustom Middleware: Create your own middleware functions Custom Handlers: Implement your own route handlers Configuration Extensions: Extend the configuration structure Hooks: Use lifecycle hooks to add custom behavior ","date":"2023-09-07","id":5,"permalink":"/docs/concepts/server-architecture/","summary":"Deep dive into the architecture of EpicServer and how its components work together.","tags":[],"title":"Server Architecture"},{"content":"This quick start guide will help you create a simple web server using EpicServer. By the end, you\u0026rsquo;ll have a working HTTP server with basic routing and logging.\nCreate a New Project First, create a new directory for your project and initialize a Go module:\nmkdir myepicserver cd myepicserver go mod init myepicserver\rInstall EpicServer Add EpicServer to your project:\ngo get -u github.com/tomskip123/EpicServer\rCreate a Basic Server Create a file named main.go with the following content:\npackage main import ( \u0026#34;github.com/tomskip123/EpicServer\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // Create a new server with default configuration server := epicserver.NewServer(\u0026amp;epicserver.Config{ Port: 8080, ReadTimeout: 30, WriteTimeout: 30, }) // Add a simple route server.GET(\u0026#34;/hello\u0026#34;, func(ctx *epicserver.Context) { ctx.String(http.StatusOK, \u0026#34;Hello, EpicServer!\u0026#34;) }) // Start the server log.Println(\u0026#34;Server starting on :8080...\u0026#34;) if err := server.Start(); err != nil { log.Fatalf(\u0026#34;Failed to start server: %v\u0026#34;, err) } }\rRun Your Server Run your server with:\ngo run main.go\rVisit http://localhost:8080/hello in your browser or use curl:\ncurl http://localhost:8080/hello\rYou should see the message \u0026ldquo;Hello, EpicServer!\u0026rdquo;.\nNext Steps Now that you have a basic server running, you can:\nLearn about Routing to add more endpoints Set up Middleware for request processing Implement Authentication for your application ","date":"2023-09-07","id":6,"permalink":"/docs/getting-started/quick-start/","summary":"A step-by-step guide to create your first EpicServer application.","tags":[],"title":"Quick Start"},{"content":"This section provides detailed explanations of the core concepts and architecture that power EpicServer. Understanding these concepts will help you make better design decisions and get the most out of EpicServer.\n","date":"2023-09-07","id":7,"permalink":"/docs/concepts/","summary":"Deep dive into the core concepts and architecture that power EpicServer.","tags":[],"title":"Core Concepts"},{"content":"Introduction to Middleware Middleware are functions that process HTTP requests before they reach your route handlers or after the response is generated. They are a powerful way to add common functionality to your web application, such as authentication, logging, CORS support, and more.\nUsing Built-in Middleware EpicServer comes with several built-in middleware functions that you can use in your application:\nLogger Middleware The logger middleware logs information about incoming HTTP requests:\nserver := epicserver.NewServer(\u0026amp;epicserver.Config{}) server.Use(epicserver.Logger())\rRecovery Middleware The recovery middleware recovers from panics and returns a 500 response:\nserver.Use(epicserver.Recovery())\rCORS Middleware The CORS middleware adds Cross-Origin Resource Sharing headers to responses:\ncorsConfig := epicserver.CORSConfig{ AllowOrigins: []string{\u0026#34;https://example.com\u0026#34;}, AllowMethods: []string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;}, AllowHeaders: []string{\u0026#34;Origin\u0026#34;, \u0026#34;Content-Type\u0026#34;}, ExposeHeaders: []string{\u0026#34;Content-Length\u0026#34;}, AllowCredentials: true, MaxAge: 12 * time.Hour, } server.Use(epicserver.CORSWithConfig(corsConfig))\rCompression Middleware The compression middleware compresses response data:\nserver.Use(epicserver.Compression())\rCreating Custom Middleware You can create your own middleware functions to add custom functionality:\nfunc AuthMiddleware() epicserver.HandlerFunc { return func(ctx *epicserver.Context) { // Get token from request token := ctx.GetHeader(\u0026#34;Authorization\u0026#34;) // Validate token if !validateToken(token) { ctx.AbortWithStatusJSON(http.StatusUnauthorized, epicserver.H{ \u0026#34;error\u0026#34;: \u0026#34;Unauthorized\u0026#34;, }) return } // Set user info in context userID := getUserIDFromToken(token) ctx.Set(\u0026#34;userID\u0026#34;, userID) // Continue to the next middleware or handler ctx.Next() } }\rThen use your custom middleware:\n// Apply to all routes server.Use(AuthMiddleware()) // Or apply to specific route groups api := server.Group(\u0026#34;/api\u0026#34;) api.Use(AuthMiddleware())\rMiddleware Order The order of middleware is important. Middleware are executed in the order they are added:\nserver.Use(epicserver.Logger()) // Executed first server.Use(epicserver.Recovery()) // Executed second server.Use(AuthMiddleware()) // Executed third\rAborting Middleware Chain Middleware can abort the request handling pipeline using Abort or AbortWithStatus:\nfunc RateLimiter() epicserver.HandlerFunc { return func(ctx *epicserver.Context) { if isRateLimited(ctx.ClientIP()) { ctx.AbortWithStatus(http.StatusTooManyRequests) return } ctx.Next() } }\rBest Practices Keep Middleware Focused: Each middleware should have a single responsibility. Consider Performance: Be aware of the performance impact of your middleware, especially for high-traffic applications. Order Matters: Place critical middleware like recovery and security early in the chain. Use Middleware for Cross-Cutting Concerns: Authentication, logging, error handling, etc., are perfect use cases for middleware. Test Middleware Independently: Write unit tests for your middleware functions. ","date":"2023-09-07","id":8,"permalink":"/docs/guides/middleware/","summary":"Complete guide to using and implementing middleware in EpicServer.","tags":[],"title":"Middleware"},{"content":"This section contains in-depth guides on how to use EpicServer\u0026rsquo;s various features. These guides provide detailed explanations and examples to help you make the most of EpicServer in your applications.\n","date":"2023-09-07","id":9,"permalink":"/docs/guides/","summary":"Detailed guides on how to use various features of EpicServer.","tags":[],"title":"Guides"},{"content":"This section provides practical code examples and sample projects to help you learn how to use EpicServer effectively. These examples cover common use cases and best practices for building web applications and APIs with EpicServer.\n","date":"2023-09-07","id":10,"permalink":"/docs/examples/","summary":"Practical examples and sample projects to help you learn EpicServer.","tags":[],"title":"Examples"},{"content":"This section provides detailed technical reference documentation for EpicServer\u0026rsquo;s API and components. It\u0026rsquo;s designed to help developers understand the full capabilities of EpicServer and how to use them effectively.\n","date":"2023-09-07","id":11,"permalink":"/docs/reference/","summary":"Detailed reference documentation for EpicServer\u0026rsquo;s API and components.","tags":[],"title":"Reference"},{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":12,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":13,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"Community GitHub Repository: EpicServer on GitHub Issues: Report bugs or request features Discussions: Join the community discussions Additional Learning Go Documentation: official Go documentation Gin Framework: Gin Web Framework RESTful API Design: Best Practices for REST API Design Tools and Integrations Visual Studio Code Go Extension: Go extension for VS Code Postman: API Development Environment Docker: Container platform Example Projects Basic API Server: EpicServer Basic API Example Authentication Service: EpicServer Auth Example RESTful API: EpicServer RESTful Example Books and Articles Building Web Applications with Go: A comprehensive guide to building web applications using Go API Design Patterns: Best practices for designing REST APIs Microservices with Go: Learn how to build microservices with Go and EpicServer Videos and Tutorials Getting Started with EpicServer: A video tutorial series covering the basics Advanced EpicServer Patterns: Deep dive into advanced usage patterns Scaling EpicServer Applications: Best practices for scaling your application ","date":"2023-09-07","id":14,"permalink":"/docs/resources/","summary":"Additional resources to help you get the most out of EpicServer.","tags":[],"title":"Resources"},{"content":"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.\nFurther reading Read about how-to guides in the Diátaxis framework ","date":"2023-09-07","id":15,"permalink":"/docs/guides/example-guide/","summary":"\u003cp\u003eGuides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.\u003c/p\u003e","tags":[],"title":"Example Guide"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":16,"permalink":"/docs/reference/example-reference/","summary":"\u003cp\u003eReference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\u003c/p\u003e","tags":[],"title":"Example Reference"},{"content":"Welcome to the official documentation for EpicServer, a powerful, flexible, and production-ready Go web server built on top of the Gin framework. This documentation will help you get started with EpicServer and provide detailed information on its features and capabilities.\n","date":"2023-09-07","id":17,"permalink":"/docs/","summary":"Complete documentation for the EpicServer Go web framework.","tags":[],"title":"EpicServer Documentation"},{"content":"","date":"2023-09-07","id":18,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"Get Started EpicServer provides a robust foundation for building web applications and APIs in Go. With features like structured logging, middleware support, and database integration, EpicServer helps you build production-ready applications quickly and confidently.\nQuick Links Installation Quick Start Guide API Reference Examples ","date":"2023-09-07","id":19,"permalink":"/","summary":"\u003ch2 id=\"get-started\"\u003eGet Started\u003c/h2\u003e\n\u003cp\u003eEpicServer provides a robust foundation for building web applications and APIs in Go. With features like structured logging, middleware support, and database integration, EpicServer helps you build production-ready applications quickly and confidently.\u003c/p\u003e","tags":[],"title":"EpicServer"},{"content":"","date":"0001-01-01","id":20,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":21,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":22,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]